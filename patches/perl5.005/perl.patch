diff -ru perl5.005.orig/Configure perl5.005/Configure
--- perl5.005.orig/Configure	2008-09-19 02:43:48.000000000 +0100
+++ perl5.005/Configure	2008-09-19 12:53:43.000000000 +0100
@@ -633,6 +633,7 @@
 loclibpth=''
 plibpth=''
 xlibpth=''
+ignore_versioned_solibs=''
 libs=''
 lns=''
 lseektype=''
@@ -836,6 +837,8 @@
 
 : default library list
 libswanted=''
+: some systems want only to use the non-versioned libso:s
+ignore_versioned_solibs=''
 : Possible local include directories to search.
 : Set locincpth to "" in a hint file to defeat local include searches.
 locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
@@ -3693,7 +3696,8 @@
 esac
 for thislib in $libswanted; do
 	
-	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
+	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`;
+		$test -f "$xxx" -a "X$ignore_versioned_solibs" = "X"; then
 		echo "Found -l$thislib (shared)."
 		case " $dflt " in
 		*"-l$thislib "*);;
@@ -11719,6 +11723,7 @@
 i_varargs='$i_varargs'
 i_varhdr='$i_varhdr'
 i_vfork='$i_vfork'
+ignore_versioned_solibs='$ignore_versioned_solibs'
 incpath='$incpath'
 inews='$inews'
 installarchlib='$installarchlib'
diff -ru perl5.005.orig/ext/DB_File/Changes perl5.005/ext/DB_File/Changes
--- perl5.005.orig/ext/DB_File/Changes	2008-09-19 02:43:48.000000000 +0100
+++ perl5.005/ext/DB_File/Changes	2004-01-13 20:15:58.000000000 +0000
@@ -1,126 +1,314 @@
 
-0.1
+1.807 1st November 2003
 
-    First Release.
+   * Fixed minor typos on pod documetation - reported by Jeremy Mates &
+     Mark Jason Dominus.
 
-0.2
+   * dbinfo updated to report when a database is encrypted.
 
-    When DB_File is opening a database file it no longer terminates the
-    process if dbopen returned an error. This allows file protection
-    errors to be caught at run time. Thanks to Judith Grass
-    <grass@cybercash.com> for spotting the bug.
+1.806 22nd October 2002
 
-0.3
+   * Fixed problem when trying to build with a multi-threaded perl.
 
-    Added prototype support for multiple btree compare callbacks.
+   * Tidied up the recursion detetion code.
 
-1.0
+   * merged core patch 17844 - missing dTHX declarations.
 
-    DB_File has been in use for over a year. To reflect that, the
-    version number has been incremented to 1.0.
+   * merged core patch 17838 
 
-    Added complete support for multiple concurrent callbacks.
+1.805 1st September 2002
 
-    Using the push method on an empty list didn't work properly. This
-    has been fixed.
+   * Added support to allow DB_File to build with Berkeley DB 4.1.X
 
-1.01
+   * Tightened up the test harness to test that calls to untie don't generate
+     the "untie attempted while %d inner references still exist" warning.
 
-    Fixed a core dump problem with SunOS.
+   * added code to guard against calling the callbacks (compare,hash & prefix) 
+     recursively.
 
-    The return value from TIEHASH wasn't set to NULL when dbopen
-    returned an error.
+   * pasing undef for the flags and/or mode when opening a database could cause
+     a "Use of uninitialized value in subroutine entry" warning. Now silenced.
 
-1.02
+   * DBM filter code beefed up to cope with read-only $_.
 
-    Merged OS/2 specific code into DB_File.xs
+1.804 2nd June 2002
 
-    Removed some redundant code in DB_File.xs.
+   * Perl core patch 14939 added a new warning to "splice". This broke the
+     db-recno test harness. Fixed.
 
-    Documentation update.
+   * merged core patches 16502 & 16540.
 
-    Allow negative subscripts with RECNO interface.
+1.803 1st March 2002
 
-    Changed the default flags from O_RDWR to O_CREAT|O_RDWR.
+   * Fixed a problem with db-btree.t where it complained about an "our"
+     variable redeclaation.
 
-    The example code which showed how to lock a database needed a call
-    to sync added. Without it the resultant database file was empty.
+   * FETCH, STORE & DELETE don't map the flags parameter into the
+     equivalent Berkeley DB function anymore.
 
-    Added get_dup method.
+1.802 6th January 2002
 
-1.03
+   * The message about some test failing in db-recno.t had the wrong test
+     numbers. Fixed.
 
-    Documentation update.
+   * merged core patch 13942.
 
-    DB_File now imports the constants (O_RDWR, O_CREAT etc.) from Fcntl
-    automatically.
+1.801 26th November 2001
 
-    The standard hash function exists is now supported.
+   * Fixed typo in Makefile.PL
 
-    Modified the behavior of get_dup. When it returns an associative
-    array, the value is the count of the number of matching BTREE
-    values.
+   * Added "clean" attribute to Makefile.PL
+ 
+1.800 23rd November 2001
 
-1.04
+   * use pport.h for perl backward compatability code.
 
-    Minor documentation changes.
+   * use new  ExtUtils::Constant module to generate XS constants.
 
-    Fixed a bug in hash_cb. Patches supplied by Dave Hammen,
-    <hammen@gothamcity.jsc.nasa.govt>.
+   * upgrade Makefile.PL upgrade/downgrade code to toggle "our" with
+     "use vars"
 
-    Fixed a bug with the constructors for DB_File::HASHINFO,
-    DB_File::BTREEINFO and DB_File::RECNOINFO. Also tidied up the
-    constructors to make them -w clean.
+1.79 22nd October 2001
 
-    Reworked part of the test harness to be more locale friendly.
+   * Added a "local $SIG{__DIE__}" inside the eval that checks for
+     the presence of XSLoader s suggested by Andrew Hryckowin.
 
-1.05
+   * merged core patch 12277.
 
-    Made all scripts in the documentation strict and -w clean.
+   * Changed NEXTKEY to not initialise the input key. It isn't used anyway.
 
-    Added logic to DB_File.xs to allow the module to be built after
-    Perl is installed.
+1.79 22nd October 2001
 
-1.06
+   * Fixed test harness for cygwin
 
-    Minor namespace cleanup: Localized PrintBtree.
+1.78 30th July 2001
 
-1.07
+   * the test in Makefile.PL for AIX used -plthreads. Should have been
+     -lpthreads
 
-    Fixed bug with RECNO, where bval wasn't defaulting to "\n".
+   * merged Core patches 
+        10372, 10335, 10372, 10534, 10549, 10643, 11051, 11194, 11432
 
-1.08
+   * added documentation patch regarding duplicate keys from Andrew Johnson
 
-    Documented operation of bval.
 
-1.09
+1.77 26th April 2001
 
-    Minor bug fix in DB_File::HASHINFO, DB_File::RECNOINFO and
-    DB_File::BTREEINFO.
+   * AIX is reported to need -lpthreads, so Makefile.PL now checks for
+     AIX and adds it to the link options.
 
-    Changed default mode to 0666.
+   * Minor documentation updates.
 
-1.10
+   * Merged Core patch 9176
 
-    Fixed fd method so that it still returns -1 for in-memory files
-    when db 1.86 is used.
+   * Added a patch from Edward Avis that adds support for splice with
+     recno databases.
 
-1.11
+   * Modified Makefile.PL to only enable the warnings pragma if using perl
+     5.6.1 or better.    
 
-    Documented the untie gotcha.
+1.76 15th January 2001
 
-1.12
+   * Added instructions for using LD_PRELOAD to get Berkeley DB 2.x to work
+     with DB_File on Linux. Thanks to Norbert Bollow for sending details of
+     this approach.
 
-    Documented the incompatibility with version 2 of Berkeley DB.
 
-1.13
+1.75 17th December 2000
 
-    Minor changes to DB_FIle.xs and DB_File.pm
+   * Fixed perl core patch 7703
 
-1.14
+   * Added suppport to allow DB_File to be built with Berkeley DB 3.2 --
+     btree_compare, btree_prefix and hash_cb needed to be changed.
 
-    Made it illegal to tie an associative array to a RECNO database and
-    an ordinary array to a HASH or BTREE database.
+   * Updated dbinfo to support Berkeley DB 3.2 file format changes.
+
+
+1.74 10th December 2000
+
+   * A "close" call in DB_File.xs needed parenthesised to stop win32 from
+     thinking it was one of its macros.
+
+   * Updated dbinfo to support Berkeley DB 3.1 file format changes.
+
+   * DB_File.pm & the test hasness now use the warnings pragma (when
+     available).
+
+   * Included Perl core patch 7703 -- size argument for hash_cb is different
+     for Berkeley DB 3.x
+
+   * Included Perl core patch 7801 -- Give __getBerkeleyDBInfo the ANSI C
+     treatment.
+
+   * @a = () produced the warning 'Argument "" isn't numeric in entersub'
+     This has been fixed. Thanks to Edward Avis for spotting this bug.
+
+   * Added note about building under Linux. Included patches.
+
+   * Included Perl core patch 8068 -- fix for bug 20001013.009 
+     When run with warnings enabled "$hash{XX} = undef " produced an
+     "Uninitialized value" warning. This has been fixed.
+
+1.73 31st May 2000
+
+   * Added support in version.c for building with threaded Perl.
+
+   * Berkeley DB 3.1 has reenabled support for null keys. The test
+     harness has been updated to reflect this.
+
+1.72 16th January 2000
+
+   * Added hints/sco.pl
+
+   * The module will now use XSLoader when it is available. When it
+     isn't it will use DynaLoader.
+
+   * The locking section in DB_File.pm has been discredited. Many thanks
+     to David Harris for spotting the underlying problem, contributing
+     the updates to the documentation and writing DB_File::Lock (available
+     on CPAN).
+
+1.71 7th September 1999
+
+   * Fixed a bug that prevented 1.70 from compiling under win32
+
+   * Updated to support Berkeley DB 3.x
+
+   * Updated dbinfo for Berkeley DB 3.x file formats.
+
+1.70 4th August 1999
+
+   * Initialise $DB_File::db_ver and $DB_File::db_version with
+     GV_ADD|GV_ADDMULT -- bug spotted by Nick Ing-Simmons.
+
+   * Added a BOOT check to test for equivalent versions of db.h &
+     libdb.a/so.
+
+1.69 3rd August 1999
+
+   * fixed a bug in push -- DB_APPEND wasn't working properly.
+
+   * Fixed the R_SETCURSOR bug introduced in 1.68
+
+   * Added a new Perl variable $DB_File::db_ver
+   
+1.68 22nd July 1999
+
+   * Merged changes from 5.005_58 
+
+   * Fixed a bug in R_IBEFORE & R_IAFTER procesing in Berkeley DB
+     2 databases.
+
+   * Added some of the examples in the POD into the test harness.
+
+1.67 6th June 1999
+
+   * Added DBM Filter documentation to DB_File.pm
+
+   * Fixed DBM Filter code to work with 5.004
+
+   * A few instances of newSVpvn were used in 1.66. This isn't available in
+     Perl 5.004_04 or earlier. Replaced with newSVpv.
+
+1.66 15th March 1999
+
+   * Added DBM Filter code
+
+1.65 6th March 1999
+
+   * Fixed a bug in the recno PUSH logic.
+   * The BOOT version check now needs 2.3.4 when using Berkeley DB version 2
+
+1.64 21st February 1999
+
+   * Tidied the 1.x to 2.x flag mapping code.
+   * Added a patch from Mark Kettenis <kettenis@wins.uva.nl> to fix a flag
+     mapping problem with O_RDONLY on the Hurd
+   * Updated the message that db-recno.t prints when tests 51, 53 or 55 fail.
+
+1.63 19th December 1998
+
+   * Fix to allow DB 2.6.x to build with DB_File
+   * Documentation updated to use push,pop etc in the RECNO example &
+     to include the find_dup & del_dup methods.
+
+1.62 30th November 1998
+
+   Added hints/dynixptx.pl.
+   Fixed typemap -- 1.61 used PL_na instead of na
+
+1.61 19th November 1998
+
+   Added a note to README about how to build Berkeley DB 2.x when
+   using HP-UX.
+   Minor modifications to get the module to build with DB 2.5.x
+   Fixed a typo in the definition of O_RDONLY, courtesy of Mark Kettenis.
+
+1.60
+   Changed the test to check for full tied array support
+
+1.59
+   Updated the license section.
+
+   Berkeley DB 2.4.10 disallows zero length keys. Tests 32 & 42 in
+   db-btree.t and test 27 in db-hash.t failed because of this change.
+   Those tests have been zapped.
+
+   Added dbinfo to the distribution.
+
+1.58
+   Tied Array support was enhanced in Perl 5.004_57. DB_File now
+   supports PUSH,POP,SHIFT,UNSHIFT & STORESIZE.
+
+   Fixed a problem with the use of sv_setpvn. When the size is
+   specified as 0, it does a strlen on the data.  This was ok for DB
+   1.x, but isn't for DB 2.x.
+
+1.57
+   If Perl has been compiled with Threads support,the symbol op will be
+   defined. This clashes with a field name in db.h, so it needs to be
+   #undef'ed before db.h is included.
+
+1.56
+   Documented the Solaris 2.5 mutex bug
+
+1.55
+   Merged 1.16 changes.
+
+1.54
+
+   Fixed a small bug in the test harness when run under win32
+   The emulation of fd when useing DB 2.x was busted.
+
+1.53
+
+   Added DB_RENUMBER to flags for recno.
+
+1.52
+
+   Patch from Nick Ing-Simmons now allows DB_File to build on NT.
+   Merged 1.15 patch.
+
+1.51
+
+    Fixed the test harness so that it doesn't expect DB_File to have
+    been installed by the main Perl build.
+
+
+    Fixed a bug in mapping 1.x O_RDONLY flag to 2.x DB_RDONLY equivalent
+
+1.50
+
+    DB_File can now build with either DB 1.x or 2.x, but not both at
+    the same time.
+
+1.16
+
+   A harmless looking tab was causing Makefile.PL to fail on AIX 3.2.5
+
+    Small fix for the AIX strict C compiler XLC which doesn't like
+    __attribute__ being defined via proto.h and redefined via db.h. Fix
+    courtesy of Jarkko Hietaniemi.
 
 1.15
 
@@ -138,68 +326,126 @@
     inherited into.
 
 
-1.16
+1.14
 
-   A harmless looking tab was causing Makefile.PL to fail on AIX 3.2.5
+    Made it illegal to tie an associative array to a RECNO database and
+    an ordinary array to a HASH or BTREE database.
 
-    Small fix for the AIX strict C compiler XLC which doesn't like
-    __attribute__ being defined via proto.h and redefined via db.h. Fix
-    courtesy of Jarkko Hietaniemi.
+1.13
 
-1.50
+    Minor changes to DB_FIle.xs and DB_File.pm
 
-    DB_File can now build with either DB 1.x or 2.x, but not both at
-    the same time.
+1.12
 
-1.51
+    Documented the incompatibility with version 2 of Berkeley DB.
 
-    Fixed the test harness so that it doesn't expect DB_File to have
-    been installed by the main Perl build.
+1.11
 
+    Documented the untie gotcha.
 
-    Fixed a bug in mapping 1.x O_RDONLY flag to 2.x DB_RDONLY equivalent
+1.10
 
-1.52
+    Fixed fd method so that it still returns -1 for in-memory files
+    when db 1.86 is used.
 
-   Patch from Nick Ing-Simmons now allows DB_File to build on NT.
-   Merged 1.15 patch.
+1.09
 
-1.53
+    Minor bug fix in DB_File::HASHINFO, DB_File::RECNOINFO and
+    DB_File::BTREEINFO.
 
-   Added DB_RENUMBER to flags for recno.
+    Changed default mode to 0666.
 
-1.54
+1.08
 
-   Fixed a small bug in the test harness when run under win32
-   The emulation of fd when useing DB 2.x was busted.
+    Documented operation of bval.
 
-1.55
-   Merged 1.16 changes.
+1.07
 
-1.56
-   Documented the Solaris 2.5 mutex bug
+    Fixed bug with RECNO, where bval wasn't defaulting to "\n".
 
-1.57
-   If Perl has been compiled with Threads support,the symbol op will be
-   defined. This clashes with a field name in db.h, so it needs to be
-   #undef'ed before db.h is included.
+1.06
 
-1.58
-   Tied Array support was enhanced in Perl 5.004_57. DB_File now
-   supports PUSH,POP,SHIFT,UNSHIFT & STORESIZE.
+    Minor namespace cleanup: Localized PrintBtree.
 
-   Fixed a problem with the use of sv_setpvn. When the size is
-   specified as 0, it does a strlen on the data.  This was ok for DB
-   1.x, but isn't for DB 2.x.
+1.05
 
-1.59
-   Updated the license section.
+    Made all scripts in the documentation strict and -w clean.
 
-   Berkeley DB 2.4.10 disallows zero length keys. Tests 32 & 42 in
-   db-btree.t and test 27 in db-hash.t failed because of this change.
-   Those tests have been zapped.
+    Added logic to DB_File.xs to allow the module to be built after
+    Perl is installed.
 
-   Added dbinfo to the distribution.
+1.04
+
+    Minor documentation changes.
+
+    Fixed a bug in hash_cb. Patches supplied by Dave Hammen,
+    <hammen@gothamcity.jsc.nasa.govt>.
+
+    Fixed a bug with the constructors for DB_File::HASHINFO,
+    DB_File::BTREEINFO and DB_File::RECNOINFO. Also tidied up the
+    constructors to make them -w clean.
+
+    Reworked part of the test harness to be more locale friendly.
+
+1.03
+
+    Documentation update.
+
+    DB_File now imports the constants (O_RDWR, O_CREAT etc.) from Fcntl
+    automatically.
+
+    The standard hash function exists is now supported.
+
+    Modified the behavior of get_dup. When it returns an associative
+    array, the value is the count of the number of matching BTREE
+    values.
+
+1.02
+
+    Merged OS/2 specific code into DB_File.xs
+
+    Removed some redundant code in DB_File.xs.
+
+    Documentation update.
+
+    Allow negative subscripts with RECNO interface.
+
+    Changed the default flags from O_RDWR to O_CREAT|O_RDWR.
+
+    The example code which showed how to lock a database needed a call
+    to sync added. Without it the resultant database file was empty.
+
+    Added get_dup method.
+
+1.01
+
+    Fixed a core dump problem with SunOS.
+
+    The return value from TIEHASH wasn't set to NULL when dbopen
+    returned an error.
+
+1.0
+
+    DB_File has been in use for over a year. To reflect that, the
+    version number has been incremented to 1.0.
+
+    Added complete support for multiple concurrent callbacks.
+
+    Using the push method on an empty list didn't work properly. This
+    has been fixed.
+
+0.3
+
+    Added prototype support for multiple btree compare callbacks.
+
+0.2
+
+    When DB_File is opening a database file it no longer terminates the
+    process if dbopen returned an error. This allows file protection
+    errors to be caught at run time. Thanks to Judith Grass
+    <grass@cybercash.com> for spotting the bug.
+
+0.1
+
+    First Release.
 
-1.60
-   Changed the test to check for full tied array support
diff -ru perl5.005.orig/ext/DB_File/DB_File.pm perl5.005/ext/DB_File/DB_File.pm
--- perl5.005.orig/ext/DB_File/DB_File.pm	2008-09-19 02:43:48.000000000 +0100
+++ perl5.005/ext/DB_File/DB_File.pm	2008-09-19 12:56:46.000000000 +0100
@@ -1,18 +1,19 @@
 # DB_File.pm -- Perl 5 interface to Berkeley DB 
 #
-# written by Paul Marquess (pmarquess@bfsec.bt.co.uk)
-# last modified 16th May 1998
-# version 1.60
+# written by Paul Marquess (pmqs@cpan.org)
+# last modified 22nd October 2002
+# version 1.807
 #
-#     Copyright (c) 1995-8 Paul Marquess. All rights reserved.
+#     Copyright (c) 1995-2003 Paul Marquess. All rights reserved.
 #     This program is free software; you can redistribute it and/or
 #     modify it under the same terms as Perl itself.
 
 
 package DB_File::HASHINFO ;
 
-require 5.003 ;
+require 5.00404;
 
+local ($^W) = 1; #use warnings;
 use strict;
 use Carp;
 require Tie::Hash;
@@ -31,8 +32,13 @@
 {
     my $pkg = shift ;
 
-    bless { VALID => { map {$_, 1} 
-		       qw( bsize ffactor nelem cachesize hash lorder)
+    bless { VALID => { 
+		       	bsize	  => 1,
+			ffactor	  => 1,
+			nelem	  => 1,
+			cachesize => 1,
+			hash	  => 2,
+			lorder	  => 1,
 		     }, 
 	    GOT   => {}
           }, $pkg ;
@@ -57,8 +63,12 @@
     my $key   = shift ;
     my $value = shift ;
 
-    if ( exists $self->{VALID}{$key} )
+    my $type = $self->{VALID}{$key};
+
+    if ( $type )
     {
+    	croak "Key '$key' not associated with a code reference" 
+	    if $type == 2 && !ref $value && ref $value ne 'CODE';
         $self->{GOT}{$key} = $value ;
         return ;
     }
@@ -104,6 +114,7 @@
 
 package DB_File::RECNOINFO ;
 
+local ($^W) = 1; #use warnings;
 use strict ;
 
 @DB_File::RECNOINFO::ISA = qw(DB_File::HASHINFO) ;
@@ -121,6 +132,7 @@
 
 package DB_File::BTREEINFO ;
 
+local ($^W) = 1; #use warnings;
 use strict ;
 
 @DB_File::BTREEINFO::ISA = qw(DB_File::HASHINFO) ;
@@ -129,9 +141,15 @@
 {
     my $pkg = shift ;
 
-    bless { VALID => { map {$_, 1} 
-		       qw( flags cachesize maxkeypage minkeypage psize 
-			   compare prefix lorder )
+    bless { VALID => { 
+		      	flags	   => 1,
+			cachesize  => 1,
+			maxkeypage => 1,
+			minkeypage => 1,
+			psize	   => 1,
+			compare	   => 2,
+			prefix	   => 2,
+			lorder	   => 1,
 	    	     },
 	    GOT   => {},
           }, $pkg ;
@@ -140,12 +158,21 @@
 
 package DB_File ;
 
+local ($^W) = 1; #use warnings;
 use strict;
-use vars qw($VERSION @ISA @EXPORT $AUTOLOAD $DB_BTREE $DB_HASH $DB_RECNO $db_version) ;
+use vars qw($VERSION @ISA @EXPORT $AUTOLOAD $DB_BTREE $DB_HASH $DB_RECNO);
+use vars qw($db_version $use_XSLoader $splice_end_array);
 use Carp;
 
 
-$VERSION = "1.60" ;
+$VERSION = "1.807" ;
+
+{
+    local $SIG{__WARN__} = sub {$splice_end_array = "@_";};
+    my @a =(1); splice(@a, 3);
+    $splice_end_array = 
+        ($splice_end_array =~ /^splice\(\) offset past end of array at /);
+}      
 
 #typedef enum { DB_BTREE, DB_HASH, DB_RECNO } DBTYPE;
 $DB_BTREE = new DB_File::BTREEINFO ;
@@ -155,8 +182,18 @@
 require Tie::Hash;
 require Exporter;
 use AutoLoader;
-require DynaLoader;
-@ISA = qw(Tie::Hash Exporter DynaLoader);
+BEGIN {
+    $use_XSLoader = 1 ;
+    { local $SIG{__DIE__} ; eval { require XSLoader } ; }
+
+    if ($@) {
+        $use_XSLoader = 0 ;
+        require DynaLoader;
+        @ISA = qw(DynaLoader);
+    }
+}
+
+push @ISA, qw(Tie::Hash Exporter);
 @EXPORT = qw(
         $DB_BTREE $DB_HASH $DB_RECNO 
 
@@ -194,21 +231,12 @@
 sub AUTOLOAD {
     my($constname);
     ($constname = $AUTOLOAD) =~ s/.*:://;
-    my $val = constant($constname, @_ ? $_[0] : 0);
-    if ($! != 0) {
-	if ($! =~ /Invalid/) {
-	    $AutoLoader::AUTOLOAD = $AUTOLOAD;
-	    goto &AutoLoader::AUTOLOAD;
-	}
-	else {
-	    my($pack,$file,$line) = caller;
-	    croak "Your vendor has not defined DB macro $constname, used at $file line $line.
-";
-	}
-    }
-    eval "sub $AUTOLOAD { $val }";
-    goto &$AUTOLOAD;
-}
+    my ($error, $val) = constant($constname);
+    Carp::croak $error if $error;
+    no strict 'refs';
+    *{$AUTOLOAD} = sub { $val };
+    goto &{$AUTOLOAD};
+}           
 
 
 eval {
@@ -219,19 +247,10 @@
     push(@EXPORT, @O);
 };
 
-## import borrowed from IO::File
-##   exports Fcntl constants if available.
-#sub import {
-#    my $pkg = shift;
-#    my $callpkg = caller;
-#    Exporter::export $pkg, $callpkg, @_;
-#    eval {
-#        require Fcntl;
-#        Exporter::export 'Fcntl', $callpkg, '/^O_/';
-#    };
-#}
-
-bootstrap DB_File $VERSION;
+if ($use_XSLoader)
+  { XSLoader::load("DB_File", $VERSION)}
+else
+  { bootstrap DB_File $VERSION }
 
 # Preloaded methods go here.  Autoload methods go after __END__, and are
 # processed by the autosplit program.
@@ -244,6 +263,9 @@
     $arg[4] = tied %{ $arg[4] } 
 	if @arg >= 5 && ref $arg[4] && $arg[4] =~ /=HASH/ && tied %{ $arg[4] } ;
 
+    $arg[2] = O_CREAT()|O_RDWR() if @arg >=3 && ! defined $arg[2];
+    $arg[3] = 0666               if @arg >=4 && ! defined $arg[3];
+
     # make recno in Berkeley DB version 2 work like recno in version 1.
     if ($db_version > 1 and defined $arg[4] and $arg[4] =~ /RECNO/ and 
 	$arg[1] and ! -e $arg[1]) {
@@ -268,7 +290,7 @@
 sub CLEAR 
 {
     my $self = shift;
-    my $key = "" ;
+    my $key = 0 ;
     my $value = "" ;
     my $status = $self->seq($key, $value, R_FIRST());
     my @keys;
@@ -300,6 +322,207 @@
     }
 }
  
+
+sub SPLICE
+{
+    my $self = shift;
+    my $offset = shift;
+    if (not defined $offset) {
+	$^W && carp('Use of uninitialized value in splice'); # warnif - 'uninitialized'
+	$offset = 0;
+    }
+
+    my $length = @_ ? shift : 0;
+    # Carping about definedness comes _after_ the OFFSET sanity check.
+    # This is so we get the same error messages as Perl's splice().
+    # 
+
+    my @list = @_;
+
+    my $size = $self->FETCHSIZE();
+    
+    # 'If OFFSET is negative then it start that far from the end of
+    # the array.'
+    # 
+    if ($offset < 0) {
+	my $new_offset = $size + $offset;
+	if ($new_offset < 0) {
+	    die "Modification of non-creatable array value attempted, "
+	      . "subscript $offset";
+	}
+	$offset = $new_offset;
+    }
+
+    if (not defined $length) {
+	$^W && carp('Use of uninitialized value in splice'); # warnif - 'uninitialized'
+	$length = 0;
+    }
+
+    if ($offset > $size) {
+ 	$offset = $size;
+	warnings::warnif('misc', 'splice() offset past end of array')
+            if $splice_end_array;
+    }
+
+    # 'If LENGTH is omitted, removes everything from OFFSET onward.'
+    if (not defined $length) {
+	$length = $size - $offset;
+    }
+
+    # 'If LENGTH is negative, leave that many elements off the end of
+    # the array.'
+    # 
+    if ($length < 0) {
+	$length = $size - $offset + $length;
+
+	if ($length < 0) {
+	    # The user must have specified a length bigger than the
+	    # length of the array passed in.  But perl's splice()
+	    # doesn't catch this, it just behaves as for length=0.
+	    # 
+	    $length = 0;
+	}
+    }
+
+    if ($length > $size - $offset) {
+	$length = $size - $offset;
+    }
+
+    # $num_elems holds the current number of elements in the database.
+    my $num_elems = $size;
+
+    # 'Removes the elements designated by OFFSET and LENGTH from an
+    # array,'...
+    # 
+    my @removed = ();
+    foreach (0 .. $length - 1) {
+	my $old;
+	my $status = $self->get($offset, $old);
+	if ($status != 0) {
+	    my $msg = "error from Berkeley DB on get($offset, \$old)";
+	    if ($status == 1) {
+		$msg .= ' (no such element?)';
+	    }
+	    else {
+		$msg .= ": error status $status";
+		if (defined $! and $! ne '') {
+		    $msg .= ", message $!";
+		}
+	    }
+	    die $msg;
+	}
+	push @removed, $old;
+
+	$status = $self->del($offset);
+	if ($status != 0) {
+	    my $msg = "error from Berkeley DB on del($offset)";
+	    if ($status == 1) {
+		$msg .= ' (no such element?)';
+	    }
+	    else {
+		$msg .= ": error status $status";
+		if (defined $! and $! ne '') {
+		    $msg .= ", message $!";
+		}
+	    }
+	    die $msg;
+	}
+
+	-- $num_elems;
+    }
+
+    # ...'and replaces them with the elements of LIST, if any.'
+    my $pos = $offset;
+    while (defined (my $elem = shift @list)) {
+	my $old_pos = $pos;
+	my $status;
+	if ($pos >= $num_elems) {
+	    $status = $self->put($pos, $elem);
+	}
+	else {
+	    $status = $self->put($pos, $elem, $self->R_IBEFORE);
+	}
+
+	if ($status != 0) {
+	    my $msg = "error from Berkeley DB on put($pos, $elem, ...)";
+	    if ($status == 1) {
+		$msg .= ' (no such element?)';
+	    }
+	    else {
+		$msg .= ", error status $status";
+		if (defined $! and $! ne '') {
+		    $msg .= ", message $!";
+		}
+	    }
+	    die $msg;
+	}
+
+	die "pos unexpectedly changed from $old_pos to $pos with R_IBEFORE"
+	  if $old_pos != $pos;
+
+	++ $pos;
+	++ $num_elems;
+    }
+
+    if (wantarray) {
+	# 'In list context, returns the elements removed from the
+	# array.'
+	# 
+	return @removed;
+    }
+    elsif (defined wantarray and not wantarray) {
+	# 'In scalar context, returns the last element removed, or
+	# undef if no elements are removed.'
+	# 
+	if (@removed) {
+	    my $last = pop @removed;
+	    return "$last";
+	}
+	else {
+	    return undef;
+	}
+    }
+    elsif (not defined wantarray) {
+	# Void context
+    }
+    else { die }
+}
+sub ::DB_File::splice { &SPLICE }
+
+sub find_dup
+{
+    croak "Usage: \$db->find_dup(key,value)\n"
+        unless @_ == 3 ;
+ 
+    my $db        = shift ;
+    my ($origkey, $value_wanted) = @_ ;
+    my ($key, $value) = ($origkey, 0);
+    my ($status) = 0 ;
+
+    for ($status = $db->seq($key, $value, R_CURSOR() ) ;
+         $status == 0 ;
+         $status = $db->seq($key, $value, R_NEXT() ) ) {
+
+        return 0 if $key eq $origkey and $value eq $value_wanted ;
+    }
+
+    return $status ;
+}
+
+sub del_dup
+{
+    croak "Usage: \$db->del_dup(key,value)\n"
+        unless @_ == 3 ;
+ 
+    my $db        = shift ;
+    my ($key, $value) = @_ ;
+    my ($status) = $db->find_dup($key, $value) ;
+    return $status if $status != 0 ;
+
+    $status = $db->del($key, R_CURSOR() ) ;
+    return $status ;
+}
+
 sub get_dup
 {
     croak "Usage: \$db->get_dup(key [,flag])\n"
@@ -347,8 +570,8 @@
 
 =head1 SYNOPSIS
 
- use DB_File ;
- 
+ use DB_File;
+
  [$X =] tie %hash,  'DB_File', [$filename, $flags, $mode, $DB_HASH] ;
  [$X =] tie %hash,  'DB_File', $filename, $flags, $mode, $DB_BTREE ;
  [$X =] tie @array, 'DB_File', $filename, $flags, $mode, $DB_RECNO ;
@@ -364,6 +587,8 @@
  $count = $X->get_dup($key) ;
  @list  = $X->get_dup($key) ;
  %list  = $X->get_dup($key, 1) ;
+ $status = $X->find_dup($key, $value) ;
+ $status = $X->del_dup($key, $value) ;
 
  # RECNO only
  $a = $X->length;
@@ -371,6 +596,13 @@
  $X->push(list);
  $a = $X->shift;
  $X->unshift(list);
+ @r = $X->splice(offset, length, elements);
+
+ # DBM Filters
+ $old_filter = $db->filter_store_key  ( sub { ... } ) ;
+ $old_filter = $db->filter_store_value( sub { ... } ) ;
+ $old_filter = $db->filter_fetch_key  ( sub { ... } ) ;
+ $old_filter = $db->filter_fetch_value( sub { ... } ) ;
 
  untie %hash ;
  untie @array ;
@@ -379,10 +611,10 @@
 
 B<DB_File> is a module which allows Perl programs to make use of the
 facilities provided by Berkeley DB version 1.x (if you have a newer
-version of DB, see L<Using DB_File with Berkeley DB version 2>). It is
-assumed that you have a copy of the Berkeley DB manual pages at hand
-when reading this documentation. The interface defined here mirrors the
-Berkeley DB interface closely.
+version of DB, see L<Using DB_File with Berkeley DB version 2 or greater>).
+It is assumed that you have a copy of the Berkeley DB manual pages at
+hand when reading this documentation. The interface defined here
+mirrors the Berkeley DB interface closely.
 
 Berkeley DB is a C library which provides a consistent interface to a
 number of database formats.  B<DB_File> provides an interface to all
@@ -423,32 +655,28 @@
 
 =back
 
-=head2 Using DB_File with Berkeley DB version 2
+=head2 Using DB_File with Berkeley DB version 2 or greater
 
 Although B<DB_File> is intended to be used with Berkeley DB version 1,
-it can also be used with version 2. In this case the interface is
+it can also be used with version 2, 3 or 4. In this case the interface is
 limited to the functionality provided by Berkeley DB 1.x. Anywhere the
-version 2 interface differs, B<DB_File> arranges for it to work like
-version 1. This feature allows B<DB_File> scripts that were built with
-version 1 to be migrated to version 2 without any changes.
+version 2 or greater interface differs, B<DB_File> arranges for it to work
+like version 1. This feature allows B<DB_File> scripts that were built
+with version 1 to be migrated to version 2 or greater without any changes.
 
 If you want to make use of the new features available in Berkeley DB
-2.x, use the Perl module B<BerkeleyDB> instead.
+2.x or greater, use the Perl module B<BerkeleyDB> instead.
 
-At the time of writing this document the B<BerkeleyDB> module is still
-alpha quality (the version number is < 1.0), and so unsuitable for use
-in any serious development work. Once its version number is >= 1.0, it
-is considered stable enough for real work.
-
-B<Note:> The database file format has changed in Berkeley DB version 2.
-If you cannot recreate your databases, you must dump any existing
-databases with the C<db_dump185> utility that comes with Berkeley DB.
-Once you have upgraded DB_File to use Berkeley DB version 2, your
-databases can be recreated using C<db_load>. Refer to the Berkeley DB
+B<Note:> The database file format has changed multiple times in Berkeley
+DB version 2, 3 and 4. If you cannot recreate your databases, you
+must dump any existing databases with either the C<db_dump> or the
+C<db_dump185> utility that comes with Berkeley DB.
+Once you have rebuilt DB_File to use Berkeley DB version 2 or greater,
+your databases can be recreated using C<db_load>. Refer to the Berkeley DB
 documentation for further details.
 
-Please read L<COPYRIGHT> before using version 2.x of Berkeley DB with
-DB_File.
+Please read L<"COPYRIGHT"> before using version 2.x or greater of Berkeley
+DB with DB_File.
 
 =head2 Interface to Berkeley DB
 
@@ -624,11 +852,13 @@
 database, delete keys/value pairs and finally how to enumerate the
 contents of the database.
 
+    use warnings ;
     use strict ;
     use DB_File ;
-    use vars qw( %h $k $v ) ;
+    our (%h, $k, $v) ;
 
-    tie %h, "DB_File", "fruit", O_RDWR|O_CREAT, 0640, $DB_HASH 
+    unlink "fruit" ;
+    tie %h, "DB_File", "fruit", O_RDWR|O_CREAT, 0666, $DB_HASH 
         or die "Cannot open file 'fruit': $!\n";
 
     # Add a few key/value pairs to the file
@@ -652,7 +882,7 @@
 here is the output:
 
     Banana Exists
- 
+
     orange -> orange
     tomato -> red
     banana -> yellow
@@ -673,6 +903,7 @@
 BTREE uses. Instead of using the normal lexical ordering, a case
 insensitive compare function will be used.
 
+    use warnings ;
     use strict ;
     use DB_File ;
 
@@ -687,7 +918,8 @@
     # specify the Perl sub that will do the comparison
     $DB_BTREE->{'compare'} = \&Compare ;
 
-    tie %h, "DB_File", "tree", O_RDWR|O_CREAT, 0640, $DB_BTREE 
+    unlink "tree" ;
+    tie %h, "DB_File", "tree", O_RDWR|O_CREAT, 0666, $DB_BTREE 
         or die "Cannot open file 'tree': $!\n" ;
 
     # Add a key/value pair to the file
@@ -728,6 +960,35 @@
 you must use the same compare function every time you access the
 database.
 
+=item 3
+
+Duplicate keys are entirely defined by the comparison function.
+In the case-insensitive example above, the keys: 'KEY' and 'key'
+would be considered duplicates, and assigning to the second one
+would overwrite the first. If duplicates are allowed for (with the
+R_DUP flag discussed below), only a single copy of duplicate keys
+is stored in the database --- so (again with example above) assigning
+three values to the keys: 'KEY', 'Key', and 'key' would leave just
+the first key: 'KEY' in the database with three values. For some
+situations this results in information loss, so care should be taken
+to provide fully qualified comparison functions when necessary.
+For example, the above comparison routine could be modified to
+additionally compare case-sensitively if two keys are equal in the
+case insensitive comparison:
+
+    sub compare {
+        my($key1, $key2) = @_;
+        lc $key1 cmp lc $key2 ||
+        $key1 cmp $key2;
+    }
+
+And now you will only have duplicates when the keys themselves
+are truly the same. (note: in versions of the db library prior to
+about November 1996, such duplicate keys were retained so it was
+possible to recover the original keys in sets of keys that
+compared as equal).
+
+
 =back 
 
 =head2 Handling Duplicate Keys 
@@ -740,20 +1001,21 @@
 want to manipulate a BTREE database with duplicate keys. Consider this
 code:
 
+    use warnings ;
     use strict ;
     use DB_File ;
 
-    use vars qw($filename %h ) ;
+    my ($filename, %h) ;
 
     $filename = "tree" ;
     unlink $filename ;
- 
+
     # Enable duplicate records
     $DB_BTREE->{'flags'} = R_DUP ;
- 
-    tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
+
+    tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE 
 	or die "Cannot open $filename: $!\n";
- 
+
     # Add some key/value pairs to the file
     $h{'Wall'} = 'Larry' ;
     $h{'Wall'} = 'Brick' ; # Note the duplicate key
@@ -763,7 +1025,7 @@
 
     # iterate through the associative array
     # and print each key/value pair.
-    foreach (keys %h)
+    foreach (sort keys %h)
       { print "$_  -> $h{$_}\n" }
 
     untie %h ;
@@ -794,27 +1056,28 @@
 
 Here is the script above rewritten using the C<seq> API method.
 
+    use warnings ;
     use strict ;
     use DB_File ;
- 
-    use vars qw($filename $x %h $status $key $value) ;
+
+    my ($filename, $x, %h, $status, $key, $value) ;
 
     $filename = "tree" ;
     unlink $filename ;
- 
+
     # Enable duplicate records
     $DB_BTREE->{'flags'} = R_DUP ;
- 
-    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
+
+    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE 
 	or die "Cannot open $filename: $!\n";
- 
+
     # Add some key/value pairs to the file
     $h{'Wall'} = 'Larry' ;
     $h{'Wall'} = 'Brick' ; # Note the duplicate key
     $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
     $h{'Smith'} = 'John' ;
     $h{'mouse'} = 'mickey' ;
- 
+
     # iterate through the btree using seq
     # and print each key/value pair.
     $key = $value = 0 ;
@@ -822,7 +1085,7 @@
          $status == 0 ;
          $status = $x->seq($key, $value, R_NEXT) )
       {  print "$key -> $value\n" }
- 
+
     undef $x ;
     untie %h ;
 
@@ -837,9 +1100,12 @@
 This time we have got all the key/value pairs, including the multiple
 values associated with the key C<Wall>.
 
+To make life easier when dealing with duplicate keys, B<DB_File> comes with 
+a few utility methods.
+
 =head2 The get_dup() Method
 
-B<DB_File> comes with a utility method, called C<get_dup>, to assist in
+The C<get_dup> method assists in
 reading duplicate values from BTREE databases. The method can take the
 following forms:
 
@@ -862,6 +1128,20 @@
 So assuming the database created above, we can use C<get_dup> like
 this:
 
+    use warnings ;
+    use strict ;
+    use DB_File ;
+
+    my ($filename, $x, %h) ;
+
+    $filename = "tree" ;
+
+    # Enable duplicate records
+    $DB_BTREE->{'flags'} = R_DUP ;
+
+    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE 
+	or die "Cannot open $filename: $!\n";
+
     my $cnt  = $x->get_dup("Wall") ;
     print "Wall occurred $cnt times\n" ;
 
@@ -869,12 +1149,12 @@
     print "Larry is there\n" if $hash{'Larry'} ;
     print "There are $hash{'Brick'} Brick Walls\n" ;
 
-    my @list = $x->get_dup("Wall") ;
+    my @list = sort $x->get_dup("Wall") ;
     print "Wall =>	[@list]\n" ;
 
     @list = $x->get_dup("Smith") ;
     print "Smith =>	[@list]\n" ;
- 
+
     @list = $x->get_dup("Dog") ;
     print "Dog =>	[@list]\n" ;
 
@@ -888,6 +1168,81 @@
     Smith =>	[John]
     Dog =>	[]
 
+=head2 The find_dup() Method
+
+    $status = $X->find_dup($key, $value) ;
+
+This method checks for the existence of a specific key/value pair. If the
+pair exists, the cursor is left pointing to the pair and the method 
+returns 0. Otherwise the method returns a non-zero value.
+
+Assuming the database from the previous example:
+
+    use warnings ;
+    use strict ;
+    use DB_File ;
+
+    my ($filename, $x, %h, $found) ;
+
+    $filename = "tree" ;
+
+    # Enable duplicate records
+    $DB_BTREE->{'flags'} = R_DUP ;
+
+    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE 
+	or die "Cannot open $filename: $!\n";
+
+    $found = ( $x->find_dup("Wall", "Larry") == 0 ? "" : "not") ; 
+    print "Larry Wall is $found there\n" ;
+
+    $found = ( $x->find_dup("Wall", "Harry") == 0 ? "" : "not") ; 
+    print "Harry Wall is $found there\n" ;
+
+    undef $x ;
+    untie %h ;
+
+prints this
+
+    Larry Wall is  there
+    Harry Wall is not there
+
+
+=head2 The del_dup() Method
+
+    $status = $X->del_dup($key, $value) ;
+
+This method deletes a specific key/value pair. It returns
+0 if they exist and have been deleted successfully.
+Otherwise the method returns a non-zero value.
+
+Again assuming the existence of the C<tree> database
+
+    use warnings ;
+    use strict ;
+    use DB_File ;
+
+    my ($filename, $x, %h, $found) ;
+
+    $filename = "tree" ;
+
+    # Enable duplicate records
+    $DB_BTREE->{'flags'} = R_DUP ;
+
+    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE 
+	or die "Cannot open $filename: $!\n";
+
+    $x->del_dup("Wall", "Larry") ;
+
+    $found = ( $x->find_dup("Wall", "Larry") == 0 ? "" : "not") ; 
+    print "Larry Wall is $found there\n" ;
+
+    undef $x ;
+    untie %h ;
+
+prints this
+
+    Larry Wall is not there
+
 =head2 Matching Partial Keys 
 
 The BTREE interface has a feature which allows partial keys to be
@@ -907,11 +1262,12 @@
 In the example script below, the C<match> sub uses this feature to find
 and print the first matching key/value pair given a partial key.
 
+    use warnings ;
     use strict ;
     use DB_File ;
     use Fcntl ;
 
-    use vars qw($filename $x %h $st $key $value) ;
+    my ($filename, $x, %h, $st, $key, $value) ;
 
     sub match
     {
@@ -925,24 +1281,24 @@
     $filename = "tree" ;
     unlink $filename ;
 
-    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE
+    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE
         or die "Cannot open $filename: $!\n";
- 
+
     # Add some key/value pairs to the file
     $h{'mouse'} = 'mickey' ;
     $h{'Wall'} = 'Larry' ;
     $h{'Walls'} = 'Brick' ; 
     $h{'Smith'} = 'John' ;
- 
+
 
     $key = $value = 0 ;
     print "IN ORDER\n" ;
     for ($st = $x->seq($key, $value, R_FIRST) ;
 	 $st == 0 ;
          $st = $x->seq($key, $value, R_NEXT) )
-	
-      {  print "$key -> $value\n" }
- 
+
+      {  print "$key	-> $value\n" }
+
     print "\nPARTIAL MATCH\n" ;
 
     match "Wa" ;
@@ -970,7 +1326,7 @@
 DB_RECNO provides an interface to flat text files. Both variable and
 fixed length records are supported.
 
-In order to make RECNO more compatible with Perl the array offset for
+In order to make RECNO more compatible with Perl, the array offset for
 all RECNO arrays begins at 0 rather than 1 as in Berkeley DB.
 
 As with normal Perl arrays, a RECNO array can be accessed using
@@ -999,21 +1355,30 @@
 
 That clarifies the situation with regards Berkeley DB itself. What
 about B<DB_File>? Well, the behavior defined in the quote above is
-quite useful, so B<DB_File> conforms it.
+quite useful, so B<DB_File> conforms to it.
 
 That means that you can specify other options (e.g. cachesize) and
 still have bval default to C<"\n"> for variable length records, and
 space for fixed length records.
 
+Also note that the bval option only allows you to specify a single byte
+as a delimiter.
+
 =head2 A Simple Example
 
-Here is a simple example that uses RECNO.
+Here is a simple example that uses RECNO (if you are using a version 
+of Perl earlier than 5.004_57 this example won't work -- see 
+L<Extra RECNO Methods> for a workaround).
 
+    use warnings ;
     use strict ;
     use DB_File ;
 
+    my $filename = "text" ;
+    unlink $filename ;
+
     my @h ;
-    tie @h, "DB_File", "text", O_RDWR|O_CREAT, 0640, $DB_RECNO 
+    tie @h, "DB_File", $filename, O_RDWR|O_CREAT, 0666, $DB_RECNO 
         or die "Cannot open file 'text': $!\n" ;
 
     # Add a few key/value pairs to the file
@@ -1021,6 +1386,18 @@
     $h[1] = "blue" ;
     $h[2] = "yellow" ;
 
+    push @h, "green", "black" ;
+
+    my $elements = scalar @h ;
+    print "The array contains $elements entries\n" ;
+
+    my $last = pop @h ;
+    print "popped $last\n" ;
+
+    unshift @h, "white" ;
+    my $first = shift @h ;
+    print "shifted $first\n" ;
+
     # Check for existence of a key
     print "Element 1 Exists with value $h[1]\n" if $h[1] ;
 
@@ -1032,17 +1409,19 @@
 
 Here is the output from the script:
 
-
+    The array contains 5 entries
+    popped black
+    shifted white
     Element 1 Exists with value blue
-    The last element is yellow
-    The 2nd last element is blue
+    The last element is green
+    The 2nd last element is yellow
 
-=head2 Extra Methods
+=head2 Extra RECNO Methods
 
 If you are using a version of Perl earlier than 5.004_57, the tied
-array interface is quite limited. The example script above will work,
-but you won't be able to use C<push>, C<pop>, C<shift>, C<unshift>
-etc. with the tied array.
+array interface is quite limited. In the example script above
+C<push>, C<pop>, C<shift>, C<unshift>
+or determining the array length will not work with a tied array.
 
 To make the interface more useful for older versions of Perl, a number
 of methods are supplied with B<DB_File> to simulate the missing array
@@ -1073,6 +1452,10 @@
 
 Returns the number of elements in the array.
 
+=item B<$X-E<gt>splice(offset, length, elements);>
+
+Returns a splice of the array.
+
 =back
 
 =head2 Another Example
@@ -1081,18 +1464,19 @@
 described above. It also makes use of the API interface directly (see 
 L<THE API INTERFACE>).
 
+    use warnings ;
     use strict ;
-    use vars qw(@h $H $file $i) ;
+    my (@h, $H, $file, $i) ;
     use DB_File ;
     use Fcntl ;
-    
+
     $file = "text" ;
 
     unlink $file ;
 
-    $H = tie @h, "DB_File", $file, O_RDWR|O_CREAT, 0640, $DB_RECNO 
+    $H = tie @h, "DB_File", $file, O_RDWR|O_CREAT, 0666, $DB_RECNO 
         or die "Cannot open file $file: $!\n" ;
-    
+
     # first create a text file to play with
     $h[0] = "zero" ;
     $h[1] = "one" ;
@@ -1100,7 +1484,7 @@
     $h[3] = "three" ;
     $h[4] = "four" ;
 
-    
+
     # Print the records in order.
     #
     # The length method is needed here because evaluating a tied
@@ -1338,8 +1722,8 @@
 
 Returns the file descriptor for the underlying database.
 
-See L<Locking Databases> for an example of how to make use of the
-C<fd> method to lock your database.
+See L<Locking: The Trouble with fd> for an explanation for why you should
+not use C<fd> to lock your database.
 
 =item B<$status = $X-E<gt>seq($key, $value, $flags) ;>
 
@@ -1360,67 +1744,264 @@
 
 =back
 
-=head1 HINTS AND TIPS 
+=head1 DBM FILTERS
 
+A DBM Filter is a piece of code that is be used when you I<always>
+want to make the same transformation to all keys and/or values in a
+DBM database.
+
+There are four methods associated with DBM Filters. All work identically,
+and each is used to install (or uninstall) a single DBM Filter. Each
+expects a single parameter, namely a reference to a sub. The only
+difference between them is the place that the filter is installed.
 
-=head2 Locking Databases
+To summarise:
 
-Concurrent access of a read-write database by several parties requires
-them all to use some kind of locking.  Here's an example of Tom's that
-uses the I<fd> method to get the file descriptor, and then a careful
-open() to give something Perl will flock() for you.  Run this repeatedly
-in the background to watch the locks granted in proper order.
+=over 5
 
-    use DB_File;
+=item B<filter_store_key>
 
-    use strict;
+If a filter has been installed with this method, it will be invoked
+every time you write a key to a DBM database.
 
-    sub LOCK_SH { 1 }
-    sub LOCK_EX { 2 }
-    sub LOCK_NB { 4 }
-    sub LOCK_UN { 8 }
+=item B<filter_store_value>
 
-    my($oldval, $fd, $db, %db, $value, $key);
+If a filter has been installed with this method, it will be invoked
+every time you write a value to a DBM database.
 
-    $key = shift || 'default';
-    $value = shift || 'magic';
 
-    $value .= " $$";
+=item B<filter_fetch_key>
 
-    $db = tie(%db, 'DB_File', '/tmp/foo.db', O_CREAT|O_RDWR, 0644) 
-	    || die "dbcreat /tmp/foo.db $!";
-    $fd = $db->fd;
-    print "$$: db fd is $fd\n";
-    open(DB_FH, "+<&=$fd") || die "dup $!";
+If a filter has been installed with this method, it will be invoked
+every time you read a key from a DBM database.
 
+=item B<filter_fetch_value>
 
-    unless (flock (DB_FH, LOCK_SH | LOCK_NB)) {
-	print "$$: CONTENTION; can't read during write update!
-		    Waiting for read lock ($!) ....";
-	unless (flock (DB_FH, LOCK_SH)) { die "flock: $!" }
-    } 
-    print "$$: Read lock granted\n";
+If a filter has been installed with this method, it will be invoked
+every time you read a value from a DBM database.
 
-    $oldval = $db{$key};
-    print "$$: Old value was $oldval\n";
-    flock(DB_FH, LOCK_UN);
+=back
+
+You can use any combination of the methods, from none, to all four.
+
+All filter methods return the existing filter, if present, or C<undef>
+in not.
+
+To delete a filter pass C<undef> to it.
+
+=head2 The Filter
+
+When each filter is called by Perl, a local copy of C<$_> will contain
+the key or value to be filtered. Filtering is achieved by modifying
+the contents of C<$_>. The return code from the filter is ignored.
+
+=head2 An Example -- the NULL termination problem.
+
+Consider the following scenario. You have a DBM database
+that you need to share with a third-party C application. The C application
+assumes that I<all> keys and values are NULL terminated. Unfortunately
+when Perl writes to DBM databases it doesn't use NULL termination, so
+your Perl application will have to manage NULL termination itself. When
+you write to the database you will have to use something like this:
+
+    $hash{"$key\0"} = "$value\0" ;
+
+Similarly the NULL needs to be taken into account when you are considering
+the length of existing keys/values.
 
-    unless (flock (DB_FH, LOCK_EX | LOCK_NB)) {
-	print "$$: CONTENTION; must have exclusive lock!
-		    Waiting for write lock ($!) ....";
-	unless (flock (DB_FH, LOCK_EX)) { die "flock: $!" }
-    } 
-
-    print "$$: Write lock granted\n";
-    $db{$key} = $value;
-    $db->sync;	# to flush
-    sleep 10;
+It would be much better if you could ignore the NULL terminations issue
+in the main application code and have a mechanism that automatically
+added the terminating NULL to all keys and values whenever you write to
+the database and have them removed when you read from the database. As I'm
+sure you have already guessed, this is a problem that DBM Filters can
+fix very easily.
 
+    use warnings ;
+    use strict ;
+    use DB_File ;
+
+    my %hash ;
+    my $filename = "/tmp/filt" ;
+    unlink $filename ;
+
+    my $db = tie %hash, 'DB_File', $filename, O_CREAT|O_RDWR, 0666, $DB_HASH 
+      or die "Cannot open $filename: $!\n" ;
+
+    # Install DBM Filters
+    $db->filter_fetch_key  ( sub { s/\0$//    } ) ;
+    $db->filter_store_key  ( sub { $_ .= "\0" } ) ;
+    $db->filter_fetch_value( sub { s/\0$//    } ) ;
+    $db->filter_store_value( sub { $_ .= "\0" } ) ;
+
+    $hash{"abc"} = "def" ;
+    my $a = $hash{"ABC"} ;
+    # ...
+    undef $db ;
+    untie %hash ;
+
+Hopefully the contents of each of the filters should be
+self-explanatory. Both "fetch" filters remove the terminating NULL,
+and both "store" filters add a terminating NULL.
+
+
+=head2 Another Example -- Key is a C int.
+
+Here is another real-life example. By default, whenever Perl writes to
+a DBM database it always writes the key and value as strings. So when
+you use this:
+
+    $hash{12345} = "soemthing" ;
+
+the key 12345 will get stored in the DBM database as the 5 byte string
+"12345". If you actually want the key to be stored in the DBM database
+as a C int, you will have to use C<pack> when writing, and C<unpack>
+when reading.
+
+Here is a DBM Filter that does it:
+
+    use warnings ;
+    use strict ;
+    use DB_File ;
+    my %hash ;
+    my $filename = "/tmp/filt" ;
+    unlink $filename ;
+
+
+    my $db = tie %hash, 'DB_File', $filename, O_CREAT|O_RDWR, 0666, $DB_HASH 
+      or die "Cannot open $filename: $!\n" ;
+
+    $db->filter_fetch_key  ( sub { $_ = unpack("i", $_) } ) ;
+    $db->filter_store_key  ( sub { $_ = pack ("i", $_) } ) ;
+    $hash{123} = "def" ;
+    # ...
+    undef $db ;
+    untie %hash ;
+
+This time only two filters have been used -- we only need to manipulate
+the contents of the key, so it wasn't necessary to install any value
+filters.
+
+=head1 HINTS AND TIPS 
+
+
+=head2 Locking: The Trouble with fd
+
+Until version 1.72 of this module, the recommended technique for locking
+B<DB_File> databases was to flock the filehandle returned from the "fd"
+function. Unfortunately this technique has been shown to be fundamentally
+flawed (Kudos to David Harris for tracking this down). Use it at your own
+peril!
+
+The locking technique went like this. 
+
+    $db = tie(%db, 'DB_File', '/tmp/foo.db', O_CREAT|O_RDWR, 0666)
+        || die "dbcreat /tmp/foo.db $!";
+    $fd = $db->fd;
+    open(DB_FH, "+<&=$fd") || die "dup $!";
+    flock (DB_FH, LOCK_EX) || die "flock: $!";
+    ...
+    $db{"Tom"} = "Jerry" ;
+    ...
     flock(DB_FH, LOCK_UN);
     undef $db;
     untie %db;
     close(DB_FH);
-    print "$$: Updated db to $key=$value\n";
+
+In simple terms, this is what happens:
+
+=over 5
+
+=item 1.
+
+Use "tie" to open the database.
+
+=item 2.
+
+Lock the database with fd & flock.
+
+=item 3.
+
+Read & Write to the database.
+
+=item 4.
+
+Unlock and close the database.
+
+=back
+
+Here is the crux of the problem. A side-effect of opening the B<DB_File>
+database in step 2 is that an initial block from the database will get
+read from disk and cached in memory.
+
+To see why this is a problem, consider what can happen when two processes,
+say "A" and "B", both want to update the same B<DB_File> database
+using the locking steps outlined above. Assume process "A" has already
+opened the database and has a write lock, but it hasn't actually updated
+the database yet (it has finished step 2, but not started step 3 yet). Now
+process "B" tries to open the same database - step 1 will succeed,
+but it will block on step 2 until process "A" releases the lock. The
+important thing to notice here is that at this point in time both
+processes will have cached identical initial blocks from the database.
+
+Now process "A" updates the database and happens to change some of the
+data held in the initial buffer. Process "A" terminates, flushing
+all cached data to disk and releasing the database lock. At this point
+the database on disk will correctly reflect the changes made by process
+"A".
+
+With the lock released, process "B" can now continue. It also updates the
+database and unfortunately it too modifies the data that was in its
+initial buffer. Once that data gets flushed to disk it will overwrite
+some/all of the changes process "A" made to the database.
+
+The result of this scenario is at best a database that doesn't contain
+what you expect. At worst the database will corrupt.
+
+The above won't happen every time competing process update the same
+B<DB_File> database, but it does illustrate why the technique should
+not be used.
+
+=head2 Safe ways to lock a database
+
+Starting with version 2.x, Berkeley DB  has internal support for locking.
+The companion module to this one, B<BerkeleyDB>, provides an interface
+to this locking functionality. If you are serious about locking
+Berkeley DB databases, I strongly recommend using B<BerkeleyDB>.
+
+If using B<BerkeleyDB> isn't an option, there are a number of modules
+available on CPAN that can be used to implement locking. Each one
+implements locking differently and has different goals in mind. It is
+therefore worth knowing the difference, so that you can pick the right
+one for your application. Here are the three locking wrappers:
+
+=over 5
+
+=item B<Tie::DB_Lock>
+
+A B<DB_File> wrapper which creates copies of the database file for
+read access, so that you have a kind of a multiversioning concurrent read
+system. However, updates are still serial. Use for databases where reads
+may be lengthy and consistency problems may occur.
+
+=item B<Tie::DB_LockFile> 
+
+A B<DB_File> wrapper that has the ability to lock and unlock the database
+while it is being used. Avoids the tie-before-flock problem by simply
+re-tie-ing the database when you get or drop a lock.  Because of the
+flexibility in dropping and re-acquiring the lock in the middle of a
+session, this can be massaged into a system that will work with long
+updates and/or reads if the application follows the hints in the POD
+documentation.
+
+=item B<DB_File::Lock> 
+
+An extremely lightweight B<DB_File> wrapper that simply flocks a lockfile
+before tie-ing the database and drops the lock after the untie. Allows
+one to use the same lockfile for multiple databases to avoid deadlock
+problems, if desired. Use for databases where updates are reads are
+quick and simple flock locking semantics are enough.
+
+=back
 
 =head2 Sharing Databases With C Applications
 
@@ -1429,7 +2010,7 @@
 
 The vast majority of problems that are reported in this area boil down
 to the fact that C strings are NULL terminated, whilst Perl strings are
-not. 
+not. See L<DBM FILTERS> for a generic way to work around this problem.
 
 Here is a real example. Netscape 2.0 keeps a record of the locations you
 visit along with the time you last visited them in a DB_HASH database.
@@ -1445,11 +2026,12 @@
 I<ggh> script (available from your nearest CPAN archive in
 F<authors/id/TOMC/scripts/nshist.gz>).
 
+    use warnings ;
     use strict ;
     use DB_File ;
     use Fcntl ;
 
-    use vars qw( $dotdir $HISTORY %hist_db $href $binary_time $date ) ;
+    my ($dotdir, $HISTORY, %hist_db, $href, $binary_time, $date) ;
     $dotdir = $ENV{HOME} || $ENV{LOGNAME};
 
     $HISTORY = "$dotdir/.netscape/history.db";
@@ -1526,7 +2108,7 @@
 untie() will destroy the first, but C<$X> still holds a valid
 reference, so the destructor will not get called and the database file
 F<tst.fil> will remain open. The fact that Berkeley DB then reports the
-attempt to open a database that is alreday open via the catch-all
+attempt to open a database that is already open via the catch-all
 "Invalid argument" doesn't help.
 
 If you run the script with the C<-w> flag the error message becomes:
@@ -1601,9 +2183,10 @@
 C<strict 'subs'> pragma (or the full strict pragma) in your script.
 Consider this script:
 
+    use warnings ;
     use strict ;
     use DB_File ;
-    use vars qw(%x) ;
+    my %x ;
     tie %x, DB_File, "filename" ;
 
 Running it produces the error in question:
@@ -1618,6 +2201,19 @@
 Although it might seem like a real pain, it is really worth the effort
 of having a C<use strict> in all your scripts.
 
+=head1 REFERENCES
+
+Articles that are either about B<DB_File> or make use of it.
+
+=over 5
+
+=item 1.
+
+I<Full-Text Searching in Perl>, Tim Kientzle (tkientzle@ddj.com),
+Dr. Dobb's Journal, Issue 295, January 1999, pp 34-41
+
+=back
+
 =head1 HISTORY
 
 Moved to the Changes file.
@@ -1640,13 +2236,12 @@
 L<perlmod/CPAN> for details), in the directory
 F<modules/by-module/DB_File>.
 
-This version of B<DB_File> will work with either version 1.x or 2.x of
-Berkeley DB, but is limited to the functionality provided by version 1.
+This version of B<DB_File> will work with either version 1.x, 2.x or
+3.x of Berkeley DB, but is limited to the functionality provided by
+version 1.
 
-The official web site for Berkeley DB is
-F<http://www.sleepycat.com/db>. The ftp equivalent is
-F<ftp.sleepycat.com:/pub>. Both versions 1 and 2 of Berkeley DB are
-available there.
+The official web site for Berkeley DB is F<http://www.sleepycat.com>.
+All versions of Berkeley DB are available there.
 
 Alternatively, Berkeley DB version 1 is available at your nearest CPAN
 archive in F<src/misc/db.1.85.tar.gz>.
@@ -1657,7 +2252,7 @@
 
 =head1 COPYRIGHT
 
-Copyright (c) 1995-8 Paul Marquess. All rights reserved. This program
+Copyright (c) 1995-2003 Paul Marquess. All rights reserved. This program
 is free software; you can redistribute it and/or modify it under the
 same terms as Perl itself.
 
@@ -1666,7 +2261,7 @@
 copyright and its own license. Please take the time to read it.
 
 Here are are few words taken from the Berkeley DB FAQ (at
-http://www.sleepycat.com) regarding the license:
+F<http://www.sleepycat.com>) regarding the license:
 
     Do I have to license DB to use it in Perl scripts? 
 
@@ -1683,12 +2278,13 @@
 
 =head1 SEE ALSO
 
-L<perl(1)>, L<dbopen(3)>, L<hash(3)>, L<recno(3)>, L<btree(3)> 
+L<perl(1)>, L<dbopen(3)>, L<hash(3)>, L<recno(3)>, L<btree(3)>,
+L<dbmfilter>
 
 =head1 AUTHOR
 
 The DB_File interface was written by Paul Marquess
-E<lt>pmarquess@bfsec.bt.co.ukE<gt>.
+E<lt>pmqs@cpan.org<gt>.
 Questions about the DB system itself may be addressed to
 E<lt>db@sleepycat.com<gt>.
 
diff -ru perl5.005.orig/ext/DB_File/DB_File.xs perl5.005/ext/DB_File/DB_File.xs
--- perl5.005.orig/ext/DB_File/DB_File.xs	2008-09-19 02:43:48.000000000 +0100
+++ perl5.005/ext/DB_File/DB_File.xs	2004-01-13 20:15:59.000000000 +0000
@@ -2,13 +2,13 @@
 
  DB_File.xs -- Perl 5 interface to Berkeley DB 
 
- written by Paul Marquess (pmarquess@bfsec.bt.co.uk)
- last modified 16th May 1998
- version 1.60
+ written by Paul Marquess <pmqs@cpan.org>
+ last modified 22nd October 2002
+ version 1.807
 
  All comments/suggestions/problems are welcome
 
-     Copyright (c) 1995, 1996, 1997, 1998 Paul Marquess. All rights reserved.
+     Copyright (c) 1995-2003 Paul Marquess. All rights reserved.
      This program is free software; you can redistribute it and/or
      modify it under the same terms as Perl itself.
 
@@ -56,52 +56,161 @@
 		This was ok for DB 1.x, but isn't for DB 2.x.
         1.59 -  No change to DB_File.xs
         1.60 -  Some code tidy up
-
-
+        1.61 -  added flagSet macro for DB 2.5.x
+		fixed typo in O_RDONLY test.
+        1.62 -  No change to DB_File.xs
+        1.63 -  Fix to alllow DB 2.6.x to build.
+        1.64 -  Tidied up the 1.x to 2.x flags mapping code.
+		Added a patch from Mark Kettenis <kettenis@wins.uva.nl>
+		to fix a flag mapping problem with O_RDONLY on the Hurd
+        1.65 -  Fixed a bug in the PUSH logic.
+		Added BOOT check that using 2.3.4 or greater
+        1.66 -  Added DBM filter code
+        1.67 -  Backed off the use of newSVpvn.
+		Fixed DBM Filter code for Perl 5.004.
+		Fixed a small memory leak in the filter code.
+        1.68 -  fixed backward compatability bug with R_IAFTER & R_IBEFORE
+		merged in the 5.005_58 changes
+        1.69 -  fixed a bug in push -- DB_APPEND wasn't working properly.
+		Fixed the R_SETCURSOR bug introduced in 1.68
+		Added a new Perl variable $DB_File::db_ver 
+        1.70 -  Initialise $DB_File::db_ver and $DB_File::db_version with 
+		GV_ADD|GV_ADDMULT -- bug spotted by Nick Ing-Simmons.
+		Added a BOOT check to test for equivalent versions of db.h &
+		libdb.a/so.
+        1.71 -  Support for Berkeley DB version 3.
+		Support for Berkeley DB 2/3's backward compatability mode.
+		Rewrote push
+        1.72 -  No change to DB_File.xs
+        1.73 -  No change to DB_File.xs
+        1.74 -  A call to open needed parenthesised to stop it clashing
+                with a win32 macro.
+		Added Perl core patches 7703 & 7801.
+        1.75 -  Fixed Perl core patch 7703.
+		Added suppport to allow DB_File to be built with 
+		Berkeley DB 3.2 -- btree_compare, btree_prefix and hash_cb
+		needed to be changed.
+        1.76 -  No change to DB_File.xs
+        1.77 -  Tidied up a few types used in calling newSVpvn.
+        1.78 -  Core patch 10335, 10372, 10534, 10549, 11051 included.
+        1.79 -  NEXTKEY ignores the input key.
+                Added lots of casts
+        1.800 - Moved backward compatability code into ppport.h.
+                Use the new constants code.
+        1.801 - No change to DB_File.xs
+        1.802 - No change to DB_File.xs
+        1.803 - FETCH, STORE & DELETE don't map the flags parameter
+                into the equivalent Berkeley DB function anymore.
+        1.804 - no change.
+        1.805 - recursion detection added to the callbacks
+                Support for 4.1.X added.
+                Filter code can now cope with read-only $_
+        1.806 - recursion detection beefed up.
+        1.807 - no change
 
 */
 
+#define PERL_NO_GET_CONTEXT
 #include "EXTERN.h"  
 #include "perl.h"
 #include "XSUB.h"
 
+#ifdef _NOT_CORE
+#  include "ppport.h"
+#endif
+
+/* Mention DB_VERSION_MAJOR_CFG, DB_VERSION_MINOR_CFG, and
+   DB_VERSION_PATCH_CFG here so that Configure pulls them all in. */
+
 /* Being the Berkeley DB we prefer the <sys/cdefs.h> (which will be
  * shortly #included by the <db.h>) __attribute__ to the possibly
  * already defined __attribute__, for example by GNUC or by Perl. */
 
-#undef __attribute__
+/* #if DB_VERSION_MAJOR_CFG < 2  */
+#ifndef DB_VERSION_MAJOR
+#    undef __attribute__
+#endif
 
-/* If Perl has been compiled with Threads support,the symbol op will
-   be defined here. This clashes with a field name in db.h, so get rid of it.
- */
-#ifdef op
-#undef op
+#ifdef COMPAT185
+#    include <db_185.h>
+#else
+#    include <db.h>
 #endif
-#include <db.h>
+
+/* Wall starts with 5.7.x */
+
+#if PERL_REVISION > 5 || (PERL_REVISION == 5 && PERL_VERSION >= 7)
+
+/* Since we dropped the gccish definition of __attribute__ we will want
+ * to redefine dNOOP, however (so that dTHX continues to work).  Yes,
+ * all this means that we can't do attribute checking on the DB_File,
+ * boo, hiss. */
+#  ifndef DB_VERSION_MAJOR
+
+#    undef  dNOOP
+#    define dNOOP extern int Perl___notused
+
+    /* Ditto for dXSARGS. */
+#    undef  dXSARGS
+#    define dXSARGS				\
+	dSP; dMARK;			\
+	I32 ax = mark - PL_stack_base + 1;	\
+	I32 items = sp - mark
+
+#  endif
+
+/* avoid -Wall; DB_File xsubs never make use of `ix' setup for ALIASes */
+#  undef dXSI32
+#  define dXSI32 dNOOP
+
+#endif /* Perl >= 5.7 */
 
 #include <fcntl.h> 
 
 /* #define TRACE */
 
+#ifdef TRACE
+#    define Trace(x)        printf x
+#else
+#    define Trace(x)
+#endif
+
 
+#define DBT_clear(x)	Zero(&x, 1, DBT) ;
 
 #ifdef DB_VERSION_MAJOR
 
+#if DB_VERSION_MAJOR == 2
+#    define BERKELEY_DB_1_OR_2
+#endif
+
+#if DB_VERSION_MAJOR > 3 || (DB_VERSION_MAJOR == 3 && DB_VERSION_MINOR >= 2)
+#    define AT_LEAST_DB_3_2
+#endif
+
+#if DB_VERSION_MAJOR > 4 || (DB_VERSION_MAJOR == 4 && DB_VERSION_MINOR >= 1)
+#    define AT_LEAST_DB_4_1
+#endif
+
 /* map version 2 features & constants onto their version 1 equivalent */
 
 #ifdef DB_Prefix_t
-#undef DB_Prefix_t
+#    undef DB_Prefix_t
 #endif
 #define DB_Prefix_t	size_t
 
 #ifdef DB_Hash_t
-#undef DB_Hash_t
+#    undef DB_Hash_t
 #endif
 #define DB_Hash_t	u_int32_t
 
 /* DBTYPE stays the same */
 /* HASHINFO, RECNOINFO and BTREEINFO  map to DB_INFO */
-typedef DB_INFO	INFO ;
+#if DB_VERSION_MAJOR == 2
+    typedef DB_INFO	INFO ;
+#else /* DB_VERSION_MAJOR > 2 */
+#    define DB_FIXEDLEN	(0x8000)
+#endif /* DB_VERSION_MAJOR == 2 */
 
 /* version 2 has db_recno_t in place of recno_t	*/
 typedef db_recno_t	recno_t;
@@ -115,11 +224,18 @@
 #define R_NEXT          DB_NEXT
 #define R_NOOVERWRITE   DB_NOOVERWRITE
 #define R_PREV          DB_PREV
-#define R_SETCURSOR     0
+
+#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 5
+#  define R_SETCURSOR	0x800000
+#else
+#  define R_SETCURSOR	(-100)
+#endif
+
 #define R_RECNOSYNC     0
 #define R_FIXEDLEN	DB_FIXEDLEN
 #define R_DUP		DB_DUP
 
+
 #define db_HA_hash 	h_hash
 #define db_HA_ffactor	h_ffactor
 #define db_HA_nelem	h_nelem
@@ -153,8 +269,17 @@
 #define DBT_flags(x)	x.flags = 0
 #define DB_flags(x, v)	x |= v 
 
+#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 5
+#    define flagSet(flags, bitmask)	((flags) & (bitmask))
+#else
+#    define flagSet(flags, bitmask)	(((flags) & DB_OPFLAGS_MASK) == (bitmask))
+#endif
+
 #else /* db version 1.x */
 
+#define BERKELEY_DB_1
+#define BERKELEY_DB_1_OR_2
+
 typedef union INFO {
         HASHINFO 	hash ;
         RECNOINFO 	recno ;
@@ -163,17 +288,17 @@
 
 
 #ifdef mDB_Prefix_t 
-#ifdef DB_Prefix_t
-#undef DB_Prefix_t
-#endif
-#define DB_Prefix_t	mDB_Prefix_t 
+#  ifdef DB_Prefix_t
+#    undef DB_Prefix_t
+#  endif
+#  define DB_Prefix_t	mDB_Prefix_t 
 #endif
 
 #ifdef mDB_Hash_t
-#ifdef DB_Hash_t
-#undef DB_Hash_t
-#endif
-#define DB_Hash_t	mDB_Hash_t
+#  ifdef DB_Hash_t
+#    undef DB_Hash_t
+#  endif
+#  define DB_Hash_t	mDB_Hash_t
 #endif
 
 #define db_HA_hash 	hash.hash
@@ -205,32 +330,36 @@
 #define do_SEQ(db, key, value, flag)	(db->dbp->seq)(db->dbp, &key, &value, flag)
 #define DBT_flags(x)	
 #define DB_flags(x, v)	
+#define flagSet(flags, bitmask)        ((flags) & (bitmask))
 
 #endif /* db version 1 */
 
 
 
-#define db_DELETE(db, key, flags)       ((db->dbp)->del)(db->dbp, TXN &key, flags)
-#define db_STORE(db, key, value, flags) ((db->dbp)->put)(db->dbp, TXN &key, &value, flags)
-#define db_FETCH(db, key, flags)        ((db->dbp)->get)(db->dbp, TXN &key, &value, flags)
+#define db_DELETE(db, key, flags)       ((db->dbp)->del)(db->dbp, TXN &key, 0)
+#define db_STORE(db, key, value, flags) ((db->dbp)->put)(db->dbp, TXN &key, &value, 0)
+#define db_FETCH(db, key, flags)        ((db->dbp)->get)(db->dbp, TXN &key, &value, 0)
 
 #define db_sync(db, flags)              ((db->dbp)->sync)(db->dbp, flags)
 #define db_get(db, key, value, flags)   ((db->dbp)->get)(db->dbp, TXN &key, &value, flags)
+
 #ifdef DB_VERSION_MAJOR
-#define db_DESTROY(db)                  ((db->dbp)->close)(db->dbp, 0)
+#define db_DESTROY(db)                  (!db->aborted && ( db->cursor->c_close(db->cursor),\
+					  (db->dbp->close)(db->dbp, 0) ))
 #define db_close(db)			((db->dbp)->close)(db->dbp, 0)
-#define db_del(db, key, flags)          ((flags & R_CURSOR) 					\
+#define db_del(db, key, flags)          (flagSet(flags, R_CURSOR) 					\
 						? ((db->cursor)->c_del)(db->cursor, 0)		\
 						: ((db->dbp)->del)(db->dbp, NULL, &key, flags) )
 
-#else
+#else /* ! DB_VERSION_MAJOR */
 
-#define db_DESTROY(db)                  ((db->dbp)->close)(db->dbp)
+#define db_DESTROY(db)                  (!db->aborted && ((db->dbp)->close)(db->dbp))
 #define db_close(db)			((db->dbp)->close)(db->dbp)
 #define db_del(db, key, flags)          ((db->dbp)->del)(db->dbp, &key, flags)
 #define db_put(db, key, value, flags)   ((db->dbp)->put)(db->dbp, &key, &value, flags)
 
-#endif
+#endif /* ! DB_VERSION_MAJOR */
+
 
 #define db_seq(db, key, value, flags)   do_SEQ(db, key, value, flags)
 
@@ -238,13 +367,25 @@
 	DBTYPE	type ;
 	DB * 	dbp ;
 	SV *	compare ;
+	bool	in_compare ;
 	SV *	prefix ;
+	bool	in_prefix ;
 	SV *	hash ;
+	bool	in_hash ;
+	bool	aborted ;
 	int	in_memory ;
+#ifdef BERKELEY_DB_1_OR_2
 	INFO 	info ;
+#endif	
 #ifdef DB_VERSION_MAJOR
 	DBC *	cursor ;
 #endif
+	SV *    filter_fetch_key ;
+	SV *    filter_store_key ;
+	SV *    filter_fetch_value ;
+	SV *    filter_store_value ;
+	int     filtering ;
+
 	} DB_File_type;
 
 typedef DB_File_type * DB_File ;
@@ -252,48 +393,109 @@
 
 #define my_sv_setpvn(sv, d, s) sv_setpvn(sv, (s ? d : (void*)""), s)
 
-#define OutputValue(arg, name)  				\
-	{ if (RETVAL == 0) {					\
-	      my_sv_setpvn(arg, name.data, name.size) ;		\
-	  }							\
+#define OutputValue(arg, name)  					\
+	{ if (RETVAL == 0) {						\
+	      my_sv_setpvn(arg, name.data, name.size) ;			\
+	      TAINT;                                       	\
+	      SvTAINTED_on(arg);                                       	\
+	      DBM_ckFilter(arg, filter_fetch_value,"filter_fetch_value") ; 	\
+	  }								\
 	}
 
-#define OutputKey(arg, name)	 				\
-	{ if (RETVAL == 0) 					\
-	  { 							\
-		if (db->type != DB_RECNO) {			\
-		    my_sv_setpvn(arg, name.data, name.size); 	\
-		}						\
-		else 						\
-		    sv_setiv(arg, (I32)*(I32*)name.data - 1); 	\
-	  } 							\
+#define OutputKey(arg, name)	 					\
+	{ if (RETVAL == 0) 						\
+	  { 								\
+		if (db->type != DB_RECNO) {				\
+		    my_sv_setpvn(arg, name.data, name.size); 		\
+		}							\
+		else 							\
+		    sv_setiv(arg, (I32)*(I32*)name.data - 1); 		\
+	      TAINT;                                       	\
+	      SvTAINTED_on(arg);                                       	\
+	      DBM_ckFilter(arg, filter_fetch_key,"filter_fetch_key") ; 	\
+	  } 								\
 	}
 
+#define my_SvUV32(sv) ((u_int32_t)SvUV(sv))
+
+#ifdef CAN_PROTOTYPE
+extern void __getBerkeleyDBInfo(void);
+#endif
 
 /* Internal Global Data */
-static recno_t Value ; 
-static recno_t zero = 0 ;
-static DB_File CurrentDB ;
-static DBTKEY empty ;
+
+#define MY_CXT_KEY "DB_File::_guts" XS_VERSION
+
+typedef struct {
+    recno_t	x_Value; 
+    recno_t	x_zero;
+    DB_File	x_CurrentDB;
+    DBTKEY	x_empty;
+} my_cxt_t;
+
+START_MY_CXT
+
+#define Value		(MY_CXT.x_Value)
+#define zero		(MY_CXT.x_zero)
+#define CurrentDB	(MY_CXT.x_CurrentDB)
+#define empty		(MY_CXT.x_empty)
+
+#define ERR_BUFF "DB_File::Error"
 
 #ifdef DB_VERSION_MAJOR
 
 static int
+#ifdef CAN_PROTOTYPE
+db_put(DB_File db, DBTKEY key, DBT value, u_int flags)
+#else
 db_put(db, key, value, flags)
 DB_File		db ;
 DBTKEY		key ;
 DBT		value ;
 u_int		flags ;
-
+#endif
 {
     int status ;
 
-    if (flags & R_CURSOR) {
-	status = ((db->cursor)->c_del)(db->cursor, 0);
-	if (status != 0)
-	    return status ;
+    if (flagSet(flags, R_IAFTER) || flagSet(flags, R_IBEFORE)) {
+        DBC * temp_cursor ;
+	DBT l_key, l_value;
+        
+#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 6
+        if (((db->dbp)->cursor)(db->dbp, NULL, &temp_cursor) != 0)
+#else
+        if (((db->dbp)->cursor)(db->dbp, NULL, &temp_cursor, 0) != 0)
+#endif
+	    return (-1) ;
+
+	memset(&l_key, 0, sizeof(l_key));
+	l_key.data = key.data;
+	l_key.size = key.size;
+	memset(&l_value, 0, sizeof(l_value));
+	l_value.data = value.data;
+	l_value.size = value.size;
+
+	if ( temp_cursor->c_get(temp_cursor, &l_key, &l_value, DB_SET) != 0) {
+	    (void)temp_cursor->c_close(temp_cursor);
+	    return (-1);
+	}
 
-	flags &= ~R_CURSOR ;
+	status = temp_cursor->c_put(temp_cursor, &key, &value, flags);
+	(void)temp_cursor->c_close(temp_cursor);
+	    
+        return (status) ;
+    }	
+    
+    
+    if (flagSet(flags, R_CURSOR)) {
+	return ((db->cursor)->c_put)(db->cursor, &key, &value, DB_CURRENT);
+    }
+
+    if (flagSet(flags, R_SETCURSOR)) {
+	if ((db->dbp)->put(db->dbp, NULL, &key, &value, 0) != 0)
+		return -1 ;
+        return ((db->cursor)->c_get)(db->cursor, &key, &value, DB_SET_RANGE);
+    
     }
 
     return ((db->dbp)->put)(db->dbp, NULL, &key, &value, flags) ;
@@ -303,49 +505,56 @@
 #endif /* DB_VERSION_MAJOR */
 
 static void
-GetVersionInfo()
+tidyUp(DB_File db)
 {
-    SV * ver_sv = perl_get_sv("DB_File::db_version", TRUE) ;
-#ifdef DB_VERSION_MAJOR
-    int Major, Minor, Patch ;
+    db->aborted = TRUE ;
+}
 
-    (void)db_version(&Major, &Minor, &Patch) ;
 
-    /* check that libdb is recent enough */
-    if (Major == 2 && Minor ==  0 && Patch < 5)
-	croak("DB_File needs Berkeley DB 2.0.5 or greater, you have %d.%d.%d\n",
-		 Major, Minor, Patch) ;
- 
-#if PATCHLEVEL > 3
-    sv_setpvf(ver_sv, "%d.%d", Major, Minor) ;
-#else
-    {
-        char buffer[40] ;
-        sprintf(buffer, "%d.%d", Major, Minor) ;
-        sv_setpv(ver_sv, buffer) ; 
-    }
-#endif
- 
-#else
-    sv_setiv(ver_sv, 1) ;
-#endif
+static int
+#ifdef AT_LEAST_DB_3_2
 
-}
+#ifdef CAN_PROTOTYPE
+btree_compare(DB * db, const DBT *key1, const DBT *key2)
+#else
+btree_compare(db, key1, key2)
+DB * db ;
+const DBT * key1 ;
+const DBT * key2 ;
+#endif /* CAN_PROTOTYPE */
 
+#else /* Berkeley DB < 3.2 */
 
-static int
+#ifdef CAN_PROTOTYPE
+btree_compare(const DBT *key1, const DBT *key2)
+#else
 btree_compare(key1, key2)
 const DBT * key1 ;
 const DBT * key2 ;
+#endif
+
+#endif
+
 {
+#ifdef dTHX
+    dTHX;
+#endif    
     dSP ;
+    dMY_CXT ;
     void * data1, * data2 ;
     int retval ;
     int count ;
     
-    data1 = key1->data ;
-    data2 = key2->data ;
 
+    if (CurrentDB->in_compare) {
+        tidyUp(CurrentDB);
+        croak ("DB_File btree_compare: recursion detected\n") ;
+    }
+
+    data1 = (char *) key1->data ;
+    data2 = (char *) key2->data ;
+
+#ifndef newSVpvn
     /* As newSVpv will assume that the data pointer is a null terminated C 
        string if the size parameter is 0, make sure that data points to an 
        empty string if the length is 0
@@ -354,45 +563,82 @@
         data1 = "" ; 
     if (key2->size == 0)
         data2 = "" ;
+#endif	
 
     ENTER ;
     SAVETMPS;
+    SAVESPTR(CurrentDB);
+    CurrentDB->in_compare = FALSE;
+    SAVEINT(CurrentDB->in_compare);
+    CurrentDB->in_compare = TRUE;
 
     PUSHMARK(SP) ;
     EXTEND(SP,2) ;
-    PUSHs(sv_2mortal(newSVpv(data1,key1->size)));
-    PUSHs(sv_2mortal(newSVpv(data2,key2->size)));
+    PUSHs(sv_2mortal(newSVpvn(data1,key1->size)));
+    PUSHs(sv_2mortal(newSVpvn(data2,key2->size)));
     PUTBACK ;
 
     count = perl_call_sv(CurrentDB->compare, G_SCALAR); 
 
     SPAGAIN ;
 
-    if (count != 1)
+    if (count != 1){
+        tidyUp(CurrentDB);
         croak ("DB_File btree_compare: expected 1 return value from compare sub, got %d\n", count) ;
+    }
 
     retval = POPi ;
 
     PUTBACK ;
     FREETMPS ;
     LEAVE ;
+
     return (retval) ;
 
 }
 
 static DB_Prefix_t
+#ifdef AT_LEAST_DB_3_2
+
+#ifdef CAN_PROTOTYPE
+btree_prefix(DB * db, const DBT *key1, const DBT *key2)
+#else
+btree_prefix(db, key1, key2)
+Db * db ;
+const DBT * key1 ;
+const DBT * key2 ;
+#endif
+
+#else /* Berkeley DB < 3.2 */
+
+#ifdef CAN_PROTOTYPE
+btree_prefix(const DBT *key1, const DBT *key2)
+#else
 btree_prefix(key1, key2)
 const DBT * key1 ;
 const DBT * key2 ;
+#endif
+
+#endif
 {
+#ifdef dTHX
+    dTHX;
+#endif    
     dSP ;
-    void * data1, * data2 ;
+    dMY_CXT ;
+    char * data1, * data2 ;
     int retval ;
     int count ;
     
-    data1 = key1->data ;
-    data2 = key2->data ;
+    if (CurrentDB->in_prefix){
+        tidyUp(CurrentDB);
+        croak ("DB_File btree_prefix: recursion detected\n") ;
+    }
+
+    data1 = (char *) key1->data ;
+    data2 = (char *) key2->data ;
 
+#ifndef newSVpvn
     /* As newSVpv will assume that the data pointer is a null terminated C 
        string if the size parameter is 0, make sure that data points to an 
        empty string if the length is 0
@@ -401,22 +647,29 @@
         data1 = "" ;
     if (key2->size == 0)
         data2 = "" ;
+#endif	
 
     ENTER ;
     SAVETMPS;
+    SAVESPTR(CurrentDB);
+    CurrentDB->in_prefix = FALSE;
+    SAVEINT(CurrentDB->in_prefix);
+    CurrentDB->in_prefix = TRUE;
 
     PUSHMARK(SP) ;
     EXTEND(SP,2) ;
-    PUSHs(sv_2mortal(newSVpv(data1,key1->size)));
-    PUSHs(sv_2mortal(newSVpv(data2,key2->size)));
+    PUSHs(sv_2mortal(newSVpvn(data1,key1->size)));
+    PUSHs(sv_2mortal(newSVpvn(data2,key2->size)));
     PUTBACK ;
 
     count = perl_call_sv(CurrentDB->prefix, G_SCALAR); 
 
     SPAGAIN ;
 
-    if (count != 1)
+    if (count != 1){
+        tidyUp(CurrentDB);
         croak ("DB_File btree_prefix: expected 1 return value from prefix sub, got %d\n", count) ;
+    }
  
     retval = POPi ;
  
@@ -427,33 +680,77 @@
     return (retval) ;
 }
 
+
+#ifdef BERKELEY_DB_1
+#    define HASH_CB_SIZE_TYPE size_t
+#else
+#    define HASH_CB_SIZE_TYPE u_int32_t
+#endif
+
 static DB_Hash_t
+#ifdef AT_LEAST_DB_3_2
+
+#ifdef CAN_PROTOTYPE
+hash_cb(DB * db, const void *data, u_int32_t size)
+#else
+hash_cb(db, data, size)
+DB * db ;
+const void * data ;
+HASH_CB_SIZE_TYPE size ;
+#endif
+
+#else /* Berkeley DB < 3.2 */
+
+#ifdef CAN_PROTOTYPE
+hash_cb(const void *data, HASH_CB_SIZE_TYPE size)
+#else
 hash_cb(data, size)
 const void * data ;
-size_t size ;
+HASH_CB_SIZE_TYPE size ;
+#endif
+
+#endif
 {
+#ifdef dTHX
+    dTHX;
+#endif    
     dSP ;
-    int retval ;
+    dMY_CXT;
+    int retval = 0;
     int count ;
 
+    if (CurrentDB->in_hash){
+        tidyUp(CurrentDB);
+        croak ("DB_File hash callback: recursion detected\n") ;
+    }
+
+#ifndef newSVpvn
     if (size == 0)
         data = "" ;
+#endif	
 
      /* DGH - Next two lines added to fix corrupted stack problem */
     ENTER ;
     SAVETMPS;
+    SAVESPTR(CurrentDB);
+    CurrentDB->in_hash = FALSE;
+    SAVEINT(CurrentDB->in_hash);
+    CurrentDB->in_hash = TRUE;
 
     PUSHMARK(SP) ;
 
-    XPUSHs(sv_2mortal(newSVpv((char*)data,size)));
+
+    XPUSHs(sv_2mortal(newSVpvn((char*)data,size)));
     PUTBACK ;
 
     count = perl_call_sv(CurrentDB->hash, G_SCALAR); 
 
     SPAGAIN ;
 
-    if (count != 1)
+    if (count != 1){
+        tidyUp(CurrentDB);
         croak ("DB_File hash_cb: expected 1 return value from hash sub, got %d\n", count) ;
+    }
 
     retval = POPi ;
 
@@ -464,12 +761,38 @@
     return (retval) ;
 }
 
+#if 0
+static void
+#ifdef CAN_PROTOTYPE
+db_errcall_cb(const char * db_errpfx, char * buffer)
+#else
+db_errcall_cb(db_errpfx, buffer)
+const char * db_errpfx;
+char * buffer;
+#endif
+{
+#ifdef dTHX
+    dTHX;
+#endif    
+    SV * sv = perl_get_sv(ERR_BUFF, FALSE) ;
+    if (sv) {
+        if (db_errpfx)
+            sv_setpvf(sv, "%s: %s", db_errpfx, buffer) ;
+        else
+            sv_setpv(sv, buffer) ;
+    }
+} 
+#endif
 
-#ifdef TRACE
+#if defined(TRACE) && defined(BERKELEY_DB_1_OR_2)
 
 static void
+#ifdef CAN_PROTOTYPE
+PrintHash(INFO *hash)
+#else
 PrintHash(hash)
 INFO * hash ;
+#endif
 {
     printf ("HASH Info\n") ;
     printf ("  hash      = %s\n", 
@@ -483,22 +806,30 @@
 }
 
 static void
+#ifdef CAN_PROTOTYPE
+PrintRecno(INFO *recno)
+#else
 PrintRecno(recno)
 INFO * recno ;
+#endif
 {
     printf ("RECNO Info\n") ;
     printf ("  flags     = %d\n", recno->db_RE_flags) ;
     printf ("  cachesize = %d\n", recno->db_RE_cachesize) ;
     printf ("  psize     = %d\n", recno->db_RE_psize) ;
     printf ("  lorder    = %d\n", recno->db_RE_lorder) ;
-    printf ("  reclen    = %ul\n", (unsigned long)recno->db_RE_reclen) ;
+    printf ("  reclen    = %lu\n", (unsigned long)recno->db_RE_reclen) ;
     printf ("  bval      = %d 0x%x\n", recno->db_RE_bval, recno->db_RE_bval) ;
     printf ("  bfname    = %d [%s]\n", recno->db_RE_bfname, recno->db_RE_bfname) ;
 }
 
 static void
+#ifdef CAN_PROTOTYPE
+PrintBtree(INFO *btree)
+#else
 PrintBtree(btree)
 INFO * btree ;
+#endif
 {
     printf ("BTREE Info\n") ;
     printf ("  compare    = %s\n", 
@@ -525,15 +856,19 @@
 
 
 static I32
+#ifdef CAN_PROTOTYPE
+GetArrayLength(pTHX_ DB_File db)
+#else
 GetArrayLength(db)
 DB_File db ;
+#endif
 {
     DBT		key ;
     DBT		value ;
     int		RETVAL ;
 
-    DBT_flags(key) ;
-    DBT_flags(value) ;
+    DBT_clear(key) ;
+    DBT_clear(value) ;
     RETVAL = do_SEQ(db, key, value, R_LAST) ;
     if (RETVAL == 0)
         RETVAL = *(I32 *)key.data ;
@@ -544,17 +879,23 @@
 }
 
 static recno_t
+#ifdef CAN_PROTOTYPE
+GetRecnoKey(pTHX_ DB_File db, I32 value)
+#else
 GetRecnoKey(db, value)
 DB_File  db ;
 I32      value ;
+#endif
 {
     if (value < 0) {
 	/* Get the length of the array */
-	I32 length = GetArrayLength(db) ;
+	I32 length = GetArrayLength(aTHX_ db) ;
 
 	/* check for attempt to write before start of array */
-	if (length + value + 1 <= 0)
+	if (length + value + 1 <= 0) {
+            tidyUp(db);
 	    croak("Modification of non-creatable array value attempted, subscript %ld", (long)value) ;
+	}
 
 	value = length + value + 1 ;
     }
@@ -564,24 +905,37 @@
     return value ;
 }
 
+
 static DB_File
+#ifdef CAN_PROTOTYPE
+ParseOpenInfo(pTHX_ int isHASH, char *name, int flags, int mode, SV *sv)
+#else
 ParseOpenInfo(isHASH, name, flags, mode, sv)
 int    isHASH ;
 char * name ;
 int    flags ;
 int    mode ;
 SV *   sv ;
+#endif
 {
+
+#ifdef BERKELEY_DB_1_OR_2 /* Berkeley DB Version 1  or 2 */
+
     SV **	svp;
     HV *	action ;
     DB_File	RETVAL = (DB_File)safemalloc(sizeof(DB_File_type)) ;
     void *	openinfo = NULL ;
     INFO	* info  = &RETVAL->info ;
+    STRLEN	n_a;
+    dMY_CXT;
 
 /* printf("In ParseOpenInfo name=[%s] flags=[%d] mode = [%d]\n", name, flags, mode) ;  */
     Zero(RETVAL, 1, DB_File_type) ;
 
     /* Default to HASH */
+    RETVAL->filtering = 0 ;
+    RETVAL->filter_fetch_key = RETVAL->filter_store_key = 
+    RETVAL->filter_fetch_value = RETVAL->filter_store_value =
     RETVAL->hash = RETVAL->compare = RETVAL->prefix = NULL ;
     RETVAL->type = DB_HASH ;
 
@@ -718,11 +1072,11 @@
 #endif
             svp = hv_fetch(action, "bfname", 6, FALSE); 
             if (svp && SvOK(*svp)) {
-		char * ptr = SvPV(*svp,PL_na) ;
+		char * ptr = SvPV(*svp,n_a) ;
 #ifdef DB_VERSION_MAJOR
-		name = (char*) PL_na ? ptr : NULL ;
+		name = (char*) n_a ? ptr : NULL ;
 #else
-                info->db_RE_bfname = (char*) (PL_na ? ptr : NULL) ;
+                info->db_RE_bfname = (char*) (n_a ? ptr : NULL) ;
 #endif
 	    }
 	    else
@@ -738,7 +1092,7 @@
             {
 		int value ;
                 if (SvPOK(*svp))
-		    value = (int)*SvPV(*svp, PL_na) ;
+		    value = (int)*SvPV(*svp, n_a) ;
 		else
 		    value = SvIV(*svp) ;
 
@@ -756,7 +1110,7 @@
             if (svp && SvOK(*svp))
             {
                 if (SvPOK(*svp))
-		    info->db_RE_bval = (u_char)*SvPV(*svp, PL_na) ;
+		    info->db_RE_bval = (u_char)*SvPV(*svp, n_a) ;
 		else
 		    info->db_RE_bval = (u_char)(unsigned long) SvIV(*svp) ;
 		DB_flags(info->flags, DB_DELIMITER) ;
@@ -800,294 +1154,320 @@
         if ((flags & O_CREAT) == O_CREAT)
             Flags |= DB_CREATE ;
 
-#ifdef O_NONBLOCK
-        if ((flags & O_NONBLOCK) == O_NONBLOCK)
-            Flags |= DB_EXCL ;
-#endif
-
 #if O_RDONLY == 0
         if (flags == O_RDONLY)
 #else
-        if (flags & O_RDONLY) == O_RDONLY)
+        if ((flags & O_RDONLY) == O_RDONLY && (flags & O_RDWR) != O_RDWR)
 #endif
             Flags |= DB_RDONLY ;
 
-#ifdef O_NONBLOCK
+#ifdef O_TRUNC
         if ((flags & O_TRUNC) == O_TRUNC)
             Flags |= DB_TRUNCATE ;
 #endif
 
         status = db_open(name, RETVAL->type, Flags, mode, NULL, openinfo, &RETVAL->dbp) ; 
         if (status == 0)
+#if DB_VERSION_MAJOR == 2 && DB_VERSION_MINOR < 6
             status = (RETVAL->dbp->cursor)(RETVAL->dbp, NULL, &RETVAL->cursor) ;
+#else
+            status = (RETVAL->dbp->cursor)(RETVAL->dbp, NULL, &RETVAL->cursor,
+			0) ;
+#endif
 
         if (status)
 	    RETVAL->dbp = NULL ;
 
     }
 #else
+
+#if defined(DB_LIBRARY_COMPATIBILITY_API) && DB_VERSION_MAJOR > 2
+    RETVAL->dbp = __db185_open(name, flags, mode, RETVAL->type, openinfo) ; 
+#else    
     RETVAL->dbp = dbopen(name, flags, mode, RETVAL->type, openinfo) ; 
+#endif /* DB_LIBRARY_COMPATIBILITY_API */
+
 #endif
 
     return (RETVAL) ;
-}
 
+#else /* Berkeley DB Version > 2 */
 
-static int
-not_here(s)
-char *s;
-{
-    croak("DB_File::%s not implemented on this architecture", s);
-    return -1;
-}
+    SV **	svp;
+    HV *	action ;
+    DB_File	RETVAL = (DB_File)safemalloc(sizeof(DB_File_type)) ;
+    DB *	dbp ;
+    STRLEN	n_a;
+    int		status ;
+    dMY_CXT;
 
-static double 
-constant(name, arg)
-char *name;
-int arg;
-{
-    errno = 0;
-    switch (*name) {
-    case 'A':
-	break;
-    case 'B':
-	if (strEQ(name, "BTREEMAGIC"))
-#ifdef BTREEMAGIC
-	    return BTREEMAGIC;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "BTREEVERSION"))
-#ifdef BTREEVERSION
-	    return BTREEVERSION;
-#else
-	    goto not_there;
-#endif
-	break;
-    case 'C':
-	break;
-    case 'D':
-	if (strEQ(name, "DB_LOCK"))
-#ifdef DB_LOCK
-	    return DB_LOCK;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "DB_SHMEM"))
-#ifdef DB_SHMEM
-	    return DB_SHMEM;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "DB_TXN"))
-#ifdef DB_TXN
-	    return (U32)DB_TXN;
-#else
-	    goto not_there;
-#endif
-	break;
-    case 'E':
-	break;
-    case 'F':
-	break;
-    case 'G':
-	break;
-    case 'H':
-	if (strEQ(name, "HASHMAGIC"))
-#ifdef HASHMAGIC
-	    return HASHMAGIC;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "HASHVERSION"))
-#ifdef HASHVERSION
-	    return HASHVERSION;
-#else
-	    goto not_there;
-#endif
-	break;
-    case 'I':
-	break;
-    case 'J':
-	break;
-    case 'K':
-	break;
-    case 'L':
-	break;
-    case 'M':
-	if (strEQ(name, "MAX_PAGE_NUMBER"))
-#ifdef MAX_PAGE_NUMBER
-	    return (U32)MAX_PAGE_NUMBER;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "MAX_PAGE_OFFSET"))
-#ifdef MAX_PAGE_OFFSET
-	    return MAX_PAGE_OFFSET;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "MAX_REC_NUMBER"))
-#ifdef MAX_REC_NUMBER
-	    return (U32)MAX_REC_NUMBER;
-#else
-	    goto not_there;
-#endif
-	break;
-    case 'N':
-	break;
-    case 'O':
-	break;
-    case 'P':
-	break;
-    case 'Q':
-	break;
-    case 'R':
-	if (strEQ(name, "RET_ERROR"))
-#ifdef RET_ERROR
-	    return RET_ERROR;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "RET_SPECIAL"))
-#ifdef RET_SPECIAL
-	    return RET_SPECIAL;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "RET_SUCCESS"))
-#ifdef RET_SUCCESS
-	    return RET_SUCCESS;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_CURSOR"))
-#ifdef R_CURSOR
-	    return R_CURSOR;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_DUP"))
-#ifdef R_DUP
-	    return R_DUP;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_FIRST"))
-#ifdef R_FIRST
-	    return R_FIRST;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_FIXEDLEN"))
-#ifdef R_FIXEDLEN
-	    return R_FIXEDLEN;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_IAFTER"))
-#ifdef R_IAFTER
-	    return R_IAFTER;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_IBEFORE"))
-#ifdef R_IBEFORE
-	    return R_IBEFORE;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_LAST"))
-#ifdef R_LAST
-	    return R_LAST;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_NEXT"))
-#ifdef R_NEXT
-	    return R_NEXT;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_NOKEY"))
-#ifdef R_NOKEY
-	    return R_NOKEY;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_NOOVERWRITE"))
-#ifdef R_NOOVERWRITE
-	    return R_NOOVERWRITE;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_PREV"))
-#ifdef R_PREV
-	    return R_PREV;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_RECNOSYNC"))
-#ifdef R_RECNOSYNC
-	    return R_RECNOSYNC;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_SETCURSOR"))
-#ifdef R_SETCURSOR
-	    return R_SETCURSOR;
-#else
-	    goto not_there;
-#endif
-	if (strEQ(name, "R_SNAPSHOT"))
-#ifdef R_SNAPSHOT
-	    return R_SNAPSHOT;
-#else
-	    goto not_there;
-#endif
-	break;
-    case 'S':
-	break;
-    case 'T':
-	break;
-    case 'U':
-	break;
-    case 'V':
-	break;
-    case 'W':
-	break;
-    case 'X':
-	break;
-    case 'Y':
-	break;
-    case 'Z':
-	break;
-    case '_':
-	break;
+/* printf("In ParseOpenInfo name=[%s] flags=[%d] mode = [%d]\n", name, flags, mode) ;  */
+    Zero(RETVAL, 1, DB_File_type) ;
+
+    /* Default to HASH */
+    RETVAL->filtering = 0 ;
+    RETVAL->filter_fetch_key = RETVAL->filter_store_key = 
+    RETVAL->filter_fetch_value = RETVAL->filter_store_value =
+    RETVAL->hash = RETVAL->compare = RETVAL->prefix = NULL ;
+    RETVAL->type = DB_HASH ;
+
+     /* DGH - Next line added to avoid SEGV on existing hash DB */
+    CurrentDB = RETVAL; 
+
+    /* fd for 1.86 hash in memory files doesn't return -1 like 1.85 */
+    RETVAL->in_memory = (name == NULL) ;
+
+    status = db_create(&RETVAL->dbp, NULL,0) ;
+    /* printf("db_create returned %d %s\n", status, db_strerror(status)) ; */
+    if (status) {
+	RETVAL->dbp = NULL ;
+        return (RETVAL) ;
+    }	
+    dbp = RETVAL->dbp ;
+
+    if (sv)
+    {
+        if (! SvROK(sv) )
+            croak ("type parameter is not a reference") ;
+
+        svp  = hv_fetch( (HV*)SvRV(sv), "GOT", 3, FALSE) ;
+        if (svp && SvOK(*svp))
+            action  = (HV*) SvRV(*svp) ;
+	else
+	    croak("internal error") ;
+
+        if (sv_isa(sv, "DB_File::HASHINFO"))
+        {
+
+	    if (!isHASH)
+	        croak("DB_File can only tie an associative array to a DB_HASH database") ;
+
+            RETVAL->type = DB_HASH ;
+  
+            svp = hv_fetch(action, "hash", 4, FALSE); 
+
+            if (svp && SvOK(*svp))
+            {
+		(void)dbp->set_h_hash(dbp, hash_cb) ;
+		RETVAL->hash = newSVsv(*svp) ;
+            }
+
+           svp = hv_fetch(action, "ffactor", 7, FALSE);
+	   if (svp)
+	       (void)dbp->set_h_ffactor(dbp, my_SvUV32(*svp)) ;
+         
+           svp = hv_fetch(action, "nelem", 5, FALSE);
+	   if (svp)
+               (void)dbp->set_h_nelem(dbp, my_SvUV32(*svp)) ;
+         
+           svp = hv_fetch(action, "bsize", 5, FALSE);
+	   if (svp)
+               (void)dbp->set_pagesize(dbp, my_SvUV32(*svp));
+           
+           svp = hv_fetch(action, "cachesize", 9, FALSE);
+	   if (svp)
+               (void)dbp->set_cachesize(dbp, 0, my_SvUV32(*svp), 0) ;
+         
+           svp = hv_fetch(action, "lorder", 6, FALSE);
+	   if (svp)
+               (void)dbp->set_lorder(dbp, (int)SvIV(*svp)) ;
+
+           PrintHash(info) ; 
+        }
+        else if (sv_isa(sv, "DB_File::BTREEINFO"))
+        {
+	    if (!isHASH)
+	        croak("DB_File can only tie an associative array to a DB_BTREE database");
+
+            RETVAL->type = DB_BTREE ;
+   
+            svp = hv_fetch(action, "compare", 7, FALSE);
+            if (svp && SvOK(*svp))
+            {
+                (void)dbp->set_bt_compare(dbp, btree_compare) ;
+		RETVAL->compare = newSVsv(*svp) ;
+            }
+
+            svp = hv_fetch(action, "prefix", 6, FALSE);
+            if (svp && SvOK(*svp))
+            {
+                (void)dbp->set_bt_prefix(dbp, btree_prefix) ;
+		RETVAL->prefix = newSVsv(*svp) ;
+            }
+
+           svp = hv_fetch(action, "flags", 5, FALSE);
+	   if (svp)
+	       (void)dbp->set_flags(dbp, my_SvUV32(*svp)) ;
+   
+           svp = hv_fetch(action, "cachesize", 9, FALSE);
+	   if (svp)
+               (void)dbp->set_cachesize(dbp, 0, my_SvUV32(*svp), 0) ;
+         
+           svp = hv_fetch(action, "psize", 5, FALSE);
+	   if (svp)
+               (void)dbp->set_pagesize(dbp, my_SvUV32(*svp)) ;
+         
+           svp = hv_fetch(action, "lorder", 6, FALSE);
+	   if (svp)
+               (void)dbp->set_lorder(dbp, (int)SvIV(*svp)) ;
+
+            PrintBtree(info) ;
+         
+        }
+        else if (sv_isa(sv, "DB_File::RECNOINFO"))
+        {
+	    int fixed = FALSE ;
+
+	    if (isHASH)
+	        croak("DB_File can only tie an array to a DB_RECNO database");
+
+            RETVAL->type = DB_RECNO ;
+
+           svp = hv_fetch(action, "flags", 5, FALSE);
+	   if (svp) {
+		int flags = SvIV(*svp) ;
+		/* remove FIXDLEN, if present */
+		if (flags & DB_FIXEDLEN) {
+		    fixed = TRUE ;
+		    flags &= ~DB_FIXEDLEN ;
+	   	}
+	   }
+
+           svp = hv_fetch(action, "cachesize", 9, FALSE);
+	   if (svp) {
+               status = dbp->set_cachesize(dbp, 0, my_SvUV32(*svp), 0) ;
+	   }
+         
+           svp = hv_fetch(action, "psize", 5, FALSE);
+	   if (svp) {
+               status = dbp->set_pagesize(dbp, my_SvUV32(*svp)) ;
+	    }
+         
+           svp = hv_fetch(action, "lorder", 6, FALSE);
+	   if (svp) {
+               status = dbp->set_lorder(dbp, (int)SvIV(*svp)) ;
+	   }
+
+	    svp = hv_fetch(action, "bval", 4, FALSE);
+            if (svp && SvOK(*svp))
+            {
+		int value ;
+                if (SvPOK(*svp))
+		    value = (int)*SvPV(*svp, n_a) ;
+		else
+		    value = (int)SvIV(*svp) ;
+
+		if (fixed) {
+		    status = dbp->set_re_pad(dbp, value) ;
+		}
+		else {
+		    status = dbp->set_re_delim(dbp, value) ;
+		}
+
+            }
+
+	   if (fixed) {
+               svp = hv_fetch(action, "reclen", 6, FALSE);
+	       if (svp) {
+		   u_int32_t len =  my_SvUV32(*svp) ;
+                   status = dbp->set_re_len(dbp, len) ;
+	       }    
+	   }
+         
+	    if (name != NULL) {
+	        status = dbp->set_re_source(dbp, name) ;
+	        name = NULL ;
+	    }	
+
+            svp = hv_fetch(action, "bfname", 6, FALSE); 
+            if (svp && SvOK(*svp)) {
+		char * ptr = SvPV(*svp,n_a) ;
+		name = (char*) n_a ? ptr : NULL ;
+	    }
+	    else
+		name = NULL ;
+         
+
+	    status = dbp->set_flags(dbp, (u_int32_t)DB_RENUMBER) ;
+         
+		if (flags){
+	            (void)dbp->set_flags(dbp, (u_int32_t)flags) ;
+		}
+            PrintRecno(info) ;
+        }
+        else
+            croak("type is not of type DB_File::HASHINFO, DB_File::BTREEINFO or DB_File::RECNOINFO");
     }
-    errno = EINVAL;
-    return 0;
 
-not_there:
-    errno = ENOENT;
-    return 0;
-}
+    {
+        u_int32_t 	Flags = 0 ;
+        int		status ;
+
+        /* Map 1.x flags to 3.x flags */
+        if ((flags & O_CREAT) == O_CREAT)
+            Flags |= DB_CREATE ;
+
+#if O_RDONLY == 0
+        if (flags == O_RDONLY)
+#else
+        if ((flags & O_RDONLY) == O_RDONLY && (flags & O_RDWR) != O_RDWR)
+#endif
+            Flags |= DB_RDONLY ;
+
+#ifdef O_TRUNC
+        if ((flags & O_TRUNC) == O_TRUNC)
+            Flags |= DB_TRUNCATE ;
+#endif
+
+#ifdef AT_LEAST_DB_4_1
+        status = (RETVAL->dbp->open)(RETVAL->dbp, NULL, name, NULL, RETVAL->type, 
+	    			Flags, mode) ; 
+#else
+        status = (RETVAL->dbp->open)(RETVAL->dbp, name, NULL, RETVAL->type, 
+	    			Flags, mode) ; 
+#endif
+	/* printf("open returned %d %s\n", status, db_strerror(status)) ; */
+
+        if (status == 0) {
+	    /* RETVAL->dbp->set_errcall(RETVAL->dbp, db_errcall_cb) ;*/
+
+            status = (RETVAL->dbp->cursor)(RETVAL->dbp, NULL, &RETVAL->cursor,
+			0) ;
+	    /* printf("cursor returned %d %s\n", status, db_strerror(status)) ; */
+	}
+
+        if (status)
+	    RETVAL->dbp = NULL ;
+
+    }
+
+    return (RETVAL) ;
+
+#endif /* Berkeley DB Version > 2 */
+
+} /* ParseOpenInfo */
+
+
+#include "constants.h"   
 
 MODULE = DB_File	PACKAGE = DB_File	PREFIX = db_
 
+INCLUDE: constants.xs
+
 BOOT:
   {
-    GetVersionInfo() ;
+#ifdef dTHX
+    dTHX;
+#endif    
+    /* SV * sv_err = perl_get_sv(ERR_BUFF, GV_ADD|GV_ADDMULTI) ;  */
+    MY_CXT_INIT;
+    __getBerkeleyDBInfo() ;
  
+    DBT_clear(empty) ; 
     empty.data = &zero ;
     empty.size =  sizeof(recno_t) ;
-    DBT_flags(empty) ; 
   }
 
-double
-constant(name,arg)
-	char *		name
-	int		arg
 
 
 DB_File
@@ -1100,14 +1480,15 @@
 	{
 	    char *	name = (char *) NULL ; 
 	    SV *	sv = (SV *) NULL ; 
+	    STRLEN	n_a;
 
 	    if (items >= 3 && SvOK(ST(2))) 
-	        name = (char*) SvPV(ST(2), PL_na) ; 
+	        name = (char*) SvPV(ST(2), n_a) ; 
 
             if (items == 6)
 	        sv = ST(5) ;
 
-	    RETVAL = ParseOpenInfo(isHASH, name, flags, mode, sv) ;
+	    RETVAL = ParseOpenInfo(aTHX_ isHASH, name, flags, mode, sv) ;
 	    if (RETVAL->dbp == NULL)
 	        RETVAL = NULL ;
 	}
@@ -1117,16 +1498,28 @@
 int
 db_DESTROY(db)
 	DB_File		db
+	PREINIT:
+	  dMY_CXT;
 	INIT:
 	  CurrentDB = db ;
+	  Trace(("DESTROY %p\n", db));
 	CLEANUP:
+	  Trace(("DESTROY %p done\n", db));
 	  if (db->hash)
 	    SvREFCNT_dec(db->hash) ;
 	  if (db->compare)
 	    SvREFCNT_dec(db->compare) ;
 	  if (db->prefix)
 	    SvREFCNT_dec(db->prefix) ;
-	  Safefree(db) ;
+	  if (db->filter_fetch_key)
+	    SvREFCNT_dec(db->filter_fetch_key) ;
+	  if (db->filter_store_key)
+	    SvREFCNT_dec(db->filter_store_key) ;
+	  if (db->filter_fetch_value)
+	    SvREFCNT_dec(db->filter_fetch_value) ;
+	  if (db->filter_store_value)
+	    SvREFCNT_dec(db->filter_store_value) ;
+	  safefree(db) ;
 #ifdef DB_VERSION_MAJOR
 	  if (RETVAL > 0)
 	    RETVAL = -1 ;
@@ -1138,6 +1531,8 @@
 	DB_File		db
 	DBTKEY		key
 	u_int		flags
+	PREINIT:
+	  dMY_CXT;
 	INIT:
 	  CurrentDB = db ;
 
@@ -1146,29 +1541,33 @@
 db_EXISTS(db, key)
 	DB_File		db
 	DBTKEY		key
+	PREINIT:
+	  dMY_CXT;
 	CODE:
 	{
           DBT		value ;
 	
-	  DBT_flags(value) ; 
+	  DBT_clear(value) ; 
 	  CurrentDB = db ;
 	  RETVAL = (((db->dbp)->get)(db->dbp, TXN &key, &value, 0) == 0) ;
 	}
 	OUTPUT:
 	  RETVAL
 
-int
+void
 db_FETCH(db, key, flags=0)
 	DB_File		db
 	DBTKEY		key
 	u_int		flags
+	PREINIT:
+	  dMY_CXT ;
+	  int RETVAL ;
 	CODE:
 	{
             DBT		value ;
 
-	    DBT_flags(value) ; 
+	    DBT_clear(value) ; 
 	    CurrentDB = db ;
-	    /* RETVAL = ((db->dbp)->get)(db->dbp, TXN &key, &value, flags) ; */
 	    RETVAL = db_get(db, key, value, flags) ;
 	    ST(0) = sv_newmortal();
 	    OutputValue(ST(0), value)
@@ -1180,37 +1579,44 @@
 	DBTKEY		key
 	DBT		value
 	u_int		flags
+	PREINIT:
+	  dMY_CXT;
 	INIT:
 	  CurrentDB = db ;
 
 
-int
+void
 db_FIRSTKEY(db)
 	DB_File		db
+	PREINIT:
+	  dMY_CXT ;
+	  int RETVAL ;
 	CODE:
 	{
 	    DBTKEY	key ;
 	    DBT		value ;
-	    DB *	Db = db->dbp ;
 
-	    DBT_flags(key) ; 
-	    DBT_flags(value) ; 
+	    DBT_clear(key) ; 
+	    DBT_clear(value) ; 
 	    CurrentDB = db ;
 	    RETVAL = do_SEQ(db, key, value, R_FIRST) ;
 	    ST(0) = sv_newmortal();
 	    OutputKey(ST(0), key) ;
 	}
 
-int
+void
 db_NEXTKEY(db, key)
 	DB_File		db
-	DBTKEY		key
+	DBTKEY		key = NO_INIT
+	PREINIT:
+	  dMY_CXT ;
+	  int RETVAL ;
 	CODE:
 	{
 	    DBT		value ;
-	    DB *	Db = db->dbp ;
 
-	    DBT_flags(value) ; 
+	    DBT_clear(key) ; 
+	    DBT_clear(value) ; 
 	    CurrentDB = db ;
 	    RETVAL = do_SEQ(db, key, value, R_NEXT) ;
 	    ST(0) = sv_newmortal();
@@ -1225,16 +1631,18 @@
 unshift(db, ...)
 	DB_File		db
 	ALIAS:		UNSHIFT = 1
+	PREINIT:
+	  dMY_CXT;
 	CODE:
 	{
 	    DBTKEY	key ;
 	    DBT		value ;
 	    int		i ;
 	    int		One ;
-	    DB *	Db = db->dbp ;
+	    STRLEN	n_a;
 
-	    DBT_flags(key) ; 
-	    DBT_flags(value) ; 
+	    DBT_clear(key) ; 
+	    DBT_clear(value) ; 
 	    CurrentDB = db ;
 #ifdef DB_VERSION_MAJOR
 	    /* get the first value */
@@ -1245,15 +1653,15 @@
 #endif
 	    for (i = items-1 ; i > 0 ; --i)
 	    {
-	        value.data = SvPV(ST(i), PL_na) ;
-	        value.size = PL_na ;
+	        value.data = SvPV(ST(i), n_a) ;
+	        value.size = n_a ;
 	        One = 1 ;
 	        key.data = &One ;
 	        key.size = sizeof(int) ;
 #ifdef DB_VERSION_MAJOR
            	RETVAL = (db->cursor->c_put)(db->cursor, &key, &value, DB_BEFORE) ;
 #else
-	        RETVAL = (Db->put)(Db, &key, &value, R_IBEFORE) ;
+	        RETVAL = (db->dbp->put)(db->dbp, &key, &value, R_IBEFORE) ;
 #endif
 	        if (RETVAL != 0)
 	            break;
@@ -1262,18 +1670,21 @@
 	OUTPUT:
 	    RETVAL
 
-I32
+void
 pop(db)
 	DB_File		db
+	PREINIT:
+	  dMY_CXT;
 	ALIAS:		POP = 1
+	PREINIT:
+	  I32 RETVAL;
 	CODE:
 	{
 	    DBTKEY	key ;
 	    DBT		value ;
-	    DB *	Db = db->dbp ;
 
-	    DBT_flags(key) ; 
-	    DBT_flags(value) ; 
+	    DBT_clear(key) ; 
+	    DBT_clear(value) ; 
 	    CurrentDB = db ;
 
 	    /* First get the final value */
@@ -1290,18 +1701,21 @@
 	    }
 	}
 
-I32
+void
 shift(db)
 	DB_File		db
+	PREINIT:
+	  dMY_CXT;
 	ALIAS:		SHIFT = 1
+	PREINIT:
+	  I32 RETVAL;
 	CODE:
 	{
 	    DBT		value ;
 	    DBTKEY	key ;
-	    DB *	Db = db->dbp ;
 
-	    DBT_flags(key) ; 
-	    DBT_flags(value) ; 
+	    DBT_clear(key) ; 
+	    DBT_clear(value) ; 
 	    CurrentDB = db ;
 	    /* get the first value */
 	    RETVAL = do_SEQ(db, key, value, R_FIRST) ;	 
@@ -1321,58 +1735,56 @@
 I32
 push(db, ...)
 	DB_File		db
+	PREINIT:
+	  dMY_CXT;
 	ALIAS:		PUSH = 1
 	CODE:
 	{
 	    DBTKEY	key ;
-	    DBTKEY *	keyptr = &key ; 
 	    DBT		value ;
 	    DB *	Db = db->dbp ;
 	    int		i ;
+	    STRLEN	n_a;
+	    int		keyval ;
 
 	    DBT_flags(key) ; 
 	    DBT_flags(value) ; 
 	    CurrentDB = db ;
 	    /* Set the Cursor to the Last element */
 	    RETVAL = do_SEQ(db, key, value, R_LAST) ;
+#ifndef DB_VERSION_MAJOR		    		    
 	    if (RETVAL >= 0)
+#endif	    
 	    {
-		if (RETVAL == 1)
-		    keyptr = &empty ;
-#ifdef DB_VERSION_MAJOR
-	        for (i = 1 ; i < items  ; ++i)
-	        {
-		    
-		    ++ (* (int*)key.data) ;
-	            value.data = SvPV(ST(i), PL_na) ;
-	            value.size = PL_na ;
-	            RETVAL = (Db->put)(Db, NULL, &key, &value, 0) ;
-	            if (RETVAL != 0)
-	                break;
-		}
-#else
-	        for (i = items - 1 ; i > 0 ; --i)
+	    	if (RETVAL == 0)
+		    keyval = *(int*)key.data ;
+		else
+		    keyval = 0 ;
+	        for (i = 1 ; i < items ; ++i)
 	        {
-	            value.data = SvPV(ST(i), PL_na) ;
-	            value.size = PL_na ;
-	            RETVAL = (Db->put)(Db, keyptr, &value, R_IAFTER) ;
+	            value.data = SvPV(ST(i), n_a) ;
+	            value.size = n_a ;
+		    ++ keyval ;
+	            key.data = &keyval ;
+	            key.size = sizeof(int) ;
+		    RETVAL = (Db->put)(Db, TXN &key, &value, 0) ;
 	            if (RETVAL != 0)
 	                break;
 	        }
-#endif
 	    }
 	}
 	OUTPUT:
 	    RETVAL
 
-
 I32
 length(db)
 	DB_File		db
+	PREINIT:
+	  dMY_CXT;
 	ALIAS:		FETCHSIZE = 1
 	CODE:
 	    CurrentDB = db ;
-	    RETVAL = GetArrayLength(db) ;
+	    RETVAL = GetArrayLength(aTHX_ db) ;
 	OUTPUT:
 	    RETVAL
 
@@ -1386,6 +1798,8 @@
 	DB_File		db
 	DBTKEY		key
 	u_int		flags
+	PREINIT:
+	  dMY_CXT;
 	CODE:
 	  CurrentDB = db ;
 	  RETVAL = db_del(db, key, flags) ;
@@ -1405,9 +1819,11 @@
 	DBTKEY		key
 	DBT		value = NO_INIT
 	u_int		flags
+	PREINIT:
+	  dMY_CXT;
 	CODE:
 	  CurrentDB = db ;
-	  DBT_flags(value) ; 
+	  DBT_clear(value) ; 
 	  RETVAL = db_get(db, key, value, flags) ;
 #ifdef DB_VERSION_MAJOR
 	  if (RETVAL > 0)
@@ -1425,6 +1841,8 @@
 	DBTKEY		key
 	DBT		value
 	u_int		flags
+	PREINIT:
+	  dMY_CXT;
 	CODE:
 	  CurrentDB = db ;
 	  RETVAL = db_put(db, key, value, flags) ;
@@ -1436,21 +1854,25 @@
 #endif
 	OUTPUT:
 	  RETVAL
-	  key		if (flags & (R_IAFTER|R_IBEFORE)) OutputKey(ST(1), key);
+	  key		if (flagSet(flags, R_IAFTER) || flagSet(flags, R_IBEFORE)) OutputKey(ST(1), key);
 
 int
 db_fd(db)
 	DB_File		db
-	int		status = 0 ;
+	PREINIT:
+	  dMY_CXT ;
 	CODE:
 	  CurrentDB = db ;
 #ifdef DB_VERSION_MAJOR
 	  RETVAL = -1 ;
-	  status = (db->in_memory
-		? -1 
-		: ((db->dbp)->fd)(db->dbp, &RETVAL) ) ;
-	  if (status != 0)
-	    RETVAL = -1 ;
+	  {
+	    int	status = 0 ;
+	    status = (db->in_memory
+		      ? -1 
+		      : ((db->dbp)->fd)(db->dbp, &RETVAL) ) ;
+	    if (status != 0)
+	      RETVAL = -1 ;
+	  }
 #else
 	  RETVAL = (db->in_memory
 		? -1 
@@ -1463,6 +1885,8 @@
 db_sync(db, flags=0)
 	DB_File		db
 	u_int		flags
+	PREINIT:
+	  dMY_CXT;
 	CODE:
 	  CurrentDB = db ;
 	  RETVAL = db_sync(db, flags) ;
@@ -1480,9 +1904,11 @@
 	DBTKEY		key 
 	DBT		value = NO_INIT
 	u_int		flags
+	PREINIT:
+	  dMY_CXT;
 	CODE:
 	  CurrentDB = db ;
-	  DBT_flags(value) ; 
+	  DBT_clear(value) ; 
 	  RETVAL = db_seq(db, key, value, flags);
 #ifdef DB_VERSION_MAJOR
 	  if (RETVAL > 0)
@@ -1495,3 +1921,35 @@
 	  key
 	  value
 
+SV *
+filter_fetch_key(db, code)
+	DB_File		db
+	SV *		code
+	SV *		RETVAL = &PL_sv_undef ;
+	CODE:
+	    DBM_setFilter(db->filter_fetch_key, code) ;
+
+SV *
+filter_store_key(db, code)
+	DB_File		db
+	SV *		code
+	SV *		RETVAL = &PL_sv_undef ;
+	CODE:
+	    DBM_setFilter(db->filter_store_key, code) ;
+
+SV *
+filter_fetch_value(db, code)
+	DB_File		db
+	SV *		code
+	SV *		RETVAL = &PL_sv_undef ;
+	CODE:
+	    DBM_setFilter(db->filter_fetch_value, code) ;
+
+SV *
+filter_store_value(db, code)
+	DB_File		db
+	SV *		code
+	SV *		RETVAL = &PL_sv_undef ;
+	CODE:
+	    DBM_setFilter(db->filter_store_value, code) ;
+
diff -ru perl5.005.orig/ext/DB_File/dbinfo perl5.005/ext/DB_File/dbinfo
--- perl5.005.orig/ext/DB_File/dbinfo	2008-09-19 02:43:48.000000000 +0100
+++ perl5.005/ext/DB_File/dbinfo	2004-01-13 20:16:00.000000000 +0000
@@ -3,11 +3,11 @@
 # Name:		dbinfo -- identify berkeley DB version used to create 
 #			  a database file
 #
-# Author:	Paul Marquess
-# Version: 	1.01 
-# Date		16th April 1998
+# Author:	Paul Marquess  <Paul.Marquess@btinternet.com>
+# Version: 	1.05 
+# Date		1sh November 2003
 #
-#     Copyright (c) 1998 Paul Marquess. All rights reserved.
+#     Copyright (c) 1998-2003 Paul Marquess. All rights reserved.
 #     This program is free software; you can redistribute it and/or
 #     modify it under the same terms as Perl itself.
 
@@ -19,26 +19,42 @@
 my %Data =
 	(
 	0x053162 =>	{
-			  Type 	=> "Btree",
+			  Type 	   => "Btree",
 			  Versions => 
 				{
-				  1	=> "Unknown (older than 1.71)",
-				  2	=> "Unknown (older than 1.71)",
-				  3	=> "1.71 -> 1.85, 1.86",
-				  4	=> "Unknown",
-				  5	=> "2.0.0 -> 2.3.0",
-				  6	=> "2.3.1 or greater",
+				  1	=> [0, "Unknown (older than 1.71)"],
+				  2	=> [0, "Unknown (older than 1.71)"],
+				  3	=> [0, "1.71 -> 1.85, 1.86"],
+				  4	=> [0, "Unknown"],
+				  5	=> [0, "2.0.0 -> 2.3.0"],
+				  6	=> [0, "2.3.1 -> 2.7.7"],
+				  7	=> [0, "3.0.x"],
+				  8	=> [0, "3.1.x -> 4.0.x"],
+				  9	=> [1, "4.1.x or greater"],
 				}
 			},
 	0x061561 => 	{
-			  Type => "Hash",
+			  Type     => "Hash",
 			  Versions =>
 				{
-				  1	=> "Unknown (older than 1.71)",
-        			  2     => "1.71 -> 1.85",
-        			  3     => "1.86",
-        			  4     => "2.0.0 -> 2.1.0",
-        			  5     => "2.2.6 or greater",
+				  1	=> [0, "Unknown (older than 1.71)"],
+        			  2     => [0, "1.71 -> 1.85"],
+        			  3     => [0, "1.86"],
+        			  4     => [0, "2.0.0 -> 2.1.0"],
+        			  5     => [0, "2.2.6 -> 2.7.7"],
+        			  6     => [0, "3.0.x"],
+				  7	=> [0, "3.1.x -> 4.0.x"],
+				  8	=> [1, "4.1.x or greater"],
+				}
+			},
+	0x042253 => 	{
+			  Type     => "Queue",
+			  Versions =>
+				{
+				  1	=> [0, "3.0.x"],
+				  2	=> [0, "3.1.x"],
+				  3	=> [0, "3.2.x -> 4.0.x"],
+				  4	=> [1, "4.1.x or greater"],
 				}
 			},
 	) ;
@@ -49,17 +65,26 @@
 open (F, "<$ARGV[0]") or die "Cannot open file $ARGV[0]: $!\n" ;
 
 my $buff ;
-read F, $buff, 20 ;
+read F, $buff, 30 ;
+
 
-my (@info) = unpack("NNNNN", $buff) ;
-my (@info1) = unpack("VVVVV", $buff) ;
-my ($magic, $version, $endian) ;
+my (@info) = unpack("NNNNNNC", $buff) ;
+my (@info1) = unpack("VVVVVVC", $buff) ;
+my ($magic, $version, $endian, $encrypt) ;
 
-if ($Data{$info[0]}) # first try DB 1.x format
+if ($Data{$info[0]}) # first try DB 1.x format, big endian
 {
     $magic = $info[0] ;
     $version = $info[1] ;
-    $endian  = "Unknown" ;
+    $endian  = "Big Endian" ;
+    $encrypt = "Not Supported";
+}
+elsif ($Data{$info1[0]}) # first try DB 1.x format, little endian
+{
+    $magic = $info1[0] ;
+    $version = $info1[1] ;
+    $endian  = "Little Endian" ;
+    $encrypt = "Not Supported";
 }
 elsif ($Data{$info[3]}) # next DB 2.x big endian
 {
@@ -77,11 +102,18 @@
   { die "not a Berkeley DB database file.\n" }
 
 my $type = $Data{$magic} ;
-my $magic = sprintf "%06X", $magic ;
+$magic = sprintf "%06X", $magic ;
 
 my $ver_string = "Unknown" ;
-$ver_string = $type->{Versions}{$version}
-	if defined $type->{Versions}{$version} ;
+
+if ( defined $type->{Versions}{$version} )
+{
+     $ver_string = $type->{Versions}{$version}[1];
+     if ($type->{Versions}{$version}[0] )
+       { $encrypt = $info[6] ? "Enabled" : "Disabled" }
+     else
+       { $encrypt = "Not Supported" }
+}
 
 print <<EOM ;
 File Type:		Berkeley DB $type->{Type} file.
@@ -89,6 +121,7 @@
 Built with Berkeley DB:	$ver_string
 Byte Order:		$endian
 Magic:			$magic
+Encryption:             $encrypt
 EOM
 
 close F ;
diff -ru perl5.005.orig/ext/DB_File/Makefile.PL perl5.005/ext/DB_File/Makefile.PL
--- perl5.005.orig/ext/DB_File/Makefile.PL	2008-09-19 02:43:48.000000000 +0100
+++ perl5.005/ext/DB_File/Makefile.PL	2004-01-13 20:16:00.000000000 +0000
@@ -1,20 +1,330 @@
+#! perl -w
+
+use strict ;
 use ExtUtils::MakeMaker 5.16 ;
 use Config ;
 
-# OS2 is a special case, so check for it now.
-my $OS2 = "-DOS2" if $Config{'osname'} eq 'os2' ;
+die "DB_File needs Perl 5.004_05 or better. This is $]\n" 
+    if $] <= 5.00404; 
+
+my $VER_INFO ;
+my $LIB_DIR ;
+my $INC_DIR ;
+my $DB_NAME ;
+my $LIBS ;
+my $COMPAT185 = "" ;
+
+ParseCONFIG() ;
+
+my @files = ('DB_File.pm', glob "t/*.t") ;
+UpDowngrade(@files);
+
+if (defined $DB_NAME)
+  { $LIBS = $DB_NAME }
+else {
+    if ($^O eq 'MSWin32')
+      { $LIBS = '-llibdb' }
+    else
+      { $LIBS = '-ldb' }
+}
+
+# Solaris is special.
+#$LIBS .= " -lthread" if $^O eq 'solaris' ;
 
-my $LIB = "-ldb" ;
-# so is win32
-$LIB = "-llibdb" if $^O eq 'MSWin32' ;
+# AIX is special.
+$LIBS .= " -lpthread" if $^O eq 'aix' ;
+
+# OS2 is a special case, so check for it now.
+my $OS2 = "" ;
+$OS2 = "-DOS2" if $Config{'osname'} eq 'os2' ;
 
 WriteMakefile(
 	NAME 		=> 'DB_File',
-	LIBS 		=> ["-L/usr/local/lib $LIB"],
-        MAN3PODS        => ' ',         # Pods will be built by installman.
-	#INC		=> '-I/usr/local/include',
+	LIBS 		=> ["-L${LIB_DIR} $LIBS"],
+        #MAN3PODS        => {},         # Pods will be built by installman.
+	INC		=> "-I$INC_DIR",
 	VERSION_FROM	=> 'DB_File.pm',
 	XSPROTOARG	=> '-noprototypes',
-	DEFINE		=> "$OS2",
+	DEFINE		=> "-D_NOT_CORE $OS2 $VER_INFO $COMPAT185",
+	OBJECT		=> 'version$(OBJ_EXT) DB_File$(OBJ_EXT)',
+	#OPTIMIZE	=> '-g',
+	'depend'	=> { 'Makefile'          => 'config.in',
+                             'version$(OBJ_EXT)' => 'version.c'},
+	'clean'		=> { FILES => 'constants.h constants.xs' },
+	'macro'		=> { INSTALLDIRS => 'perl', my_files => "@files" },
+        'dist'          => { COMPRESS => 'gzip', SUFFIX => 'gz',
+			     DIST_DEFAULT => 'MyDoubleCheck tardist'},    
 	);
 
+
+my @names = qw(
+	BTREEMAGIC
+	BTREEVERSION
+	DB_LOCK
+	DB_SHMEM
+	DB_TXN
+	HASHMAGIC
+	HASHVERSION
+	MAX_PAGE_NUMBER
+	MAX_PAGE_OFFSET
+	MAX_REC_NUMBER
+	RET_ERROR
+	RET_SPECIAL
+	RET_SUCCESS
+	R_CURSOR
+	R_DUP
+	R_FIRST
+	R_FIXEDLEN
+	R_IAFTER
+	R_IBEFORE
+	R_LAST
+	R_NEXT
+	R_NOKEY
+	R_NOOVERWRITE
+	R_PREV
+	R_RECNOSYNC
+	R_SETCURSOR
+	R_SNAPSHOT
+	__R_UNUSED
+	);
+
+if (eval {require ExtUtils::Constant; 1}) {
+    # Check the constants above all appear in @EXPORT in DB_File.pm
+    my %names = map { $_, 1} @names;
+    open F, "<DB_File.pm" or die "Cannot open DB_File.pm: $!\n";
+    while (<F>)
+    {
+        last if /^\s*\@EXPORT\s+=\s+qw\(/ ;
+    }
+
+    while (<F>)
+    {
+        last if /^\s*\)/ ;
+        /(\S+)/ ;
+        delete $names{$1} if defined $1 ;
+    }
+    close F ;
+
+    if ( keys %names )
+    {
+        my $missing = join ("\n\t", sort keys %names) ;
+        die "The following names are missing from \@EXPORT in DB_File.pm\n" .
+            "\t$missing\n" ;
+    }
+    
+
+    ExtUtils::Constant::WriteConstants(
+                                     NAME => 'DB_File',
+                                     NAMES => \@names,
+                                     C_FILE  => 'constants.h',
+                                     XS_FILE  => 'constants.xs',
+                                                                       
+                                    );
+} 
+else {
+    use File::Copy;
+    copy ('fallback.h', 'constants.h')
+      or die "Can't copy fallback.h to constants.h: $!";
+    copy ('fallback.xs', 'constants.xs')
+      or die "Can't copy fallback.xs to constants.xs: $!";
+}
+
+exit;
+
+
+sub MY::postamble { <<'EOM' } ;
+
+MyDoubleCheck:
+	@echo Checking config.in is setup for a release
+	@(grep "^LIB.*/usr/local/BerkeleyDB" config.in && 	\
+	grep "^INCLUDE.*/usr/local/BerkeleyDB" config.in &&	\
+	grep "^#DBNAME.*" config.in) >/dev/null ||		\
+	    (echo config.in needs fixing ; exit 1)
+	@echo config.in is ok
+	@echo 
+	@echo Checking DB_File.xs is ok for a release.
+	@(perl -ne ' exit 1 if /^\s*#\s*define\s+TRACE/ ; ' DB_File.xs || \
+	    (echo DB_File.xs needs fixing ; exit 1))
+	@echo DB_File.xs is ok
+	@echo 
+	@echo Checking for $$^W in files: $(my_files)
+	@perl -ne '						\
+	    exit 1 if /^\s*local\s*\(\s*\$$\^W\s*\)/;' $(my_files) ||	\
+	  (echo found unexpected $$^W ; exit 1)
+	@echo No $$^W found.
+	@echo 
+	@echo Checking for 'use vars' in files: $(my_files)
+	@perl -ne '						\
+	    exit 0 if /^__(DATA|END)__/;               	\
+	    exit 1 if /^\s*use\s+vars/;' $(my_files) ||	\
+	  (echo found unexpected "use vars"; exit 1)
+	@echo No 'use vars' found.
+	@echo 
+	@echo All files are OK for a release.
+	@echo 
+
+EOM
+
+
+
+sub ParseCONFIG
+{
+    my ($k, $v) ;
+    my @badkey = () ;
+    my %Info = () ;
+    my @Options = qw( INCLUDE LIB PREFIX HASH DBNAME COMPAT185 ) ;
+    my %ValidOption = map {$_, 1} @Options ;
+    my %Parsed = %ValidOption ;
+    my $CONFIG = 'config.in' ;
+
+    print "Parsing $CONFIG...\n" ;
+
+    # DBNAME & COMPAT185 are optional, so pretend they  have 
+    # been parsed.
+    delete $Parsed{'DBNAME'} ;
+    delete $Parsed{'COMPAT185'} ;
+    $Info{COMPAT185} = "No" ;
+
+
+    open(F, "$CONFIG") or die "Cannot open file $CONFIG: $!\n" ;
+    while (<F>) {
+	s/^\s*|\s*$//g ;
+	next if /^\s*$/ or /^\s*#/ ;
+	s/\s*#\s*$// ;
+
+	($k, $v) = split(/\s+=\s+/, $_, 2) ;
+	$k = uc $k ;
+	if ($ValidOption{$k}) {
+	    delete $Parsed{$k} ;
+	    $Info{$k} = $v ;
+	}
+	else {
+	    push(@badkey, $k) ;
+	}
+    }
+    close F ;
+
+    print "Unknown keys in $CONFIG ignored [@badkey]\n"
+	if @badkey ;
+
+    # check parsed values
+    my @missing = () ;
+    die "The following keys are missing from $CONFIG file: [@missing]\n" 
+        if @missing = keys %Parsed ;
+
+    $INC_DIR = $ENV{'DB_FILE_INCLUDE'} || $Info{'INCLUDE'} ;
+    $LIB_DIR = $ENV{'DB_FILE_LIB'} || $Info{'LIB'} ;
+    $DB_NAME = $ENV{'DB_FILE_NAME'} || $Info{'DBNAME'} ;
+    $COMPAT185 = "-DCOMPAT185 -DDB_LIBRARY_COMPATIBILITY_API" 
+        if (defined $ENV{'DB_FILE_COMPAT185'} && 
+		$ENV{'DB_FILE_COMPAT185'} =~ /^\s*(on|true|1)\s*$/i) ||
+		$Info{'COMPAT185'} =~ /^\s*(on|true|1)\s*$/i ; 
+    my $PREFIX  = $Info{'PREFIX'} ;
+    my $HASH    = $Info{'HASH'} ;
+
+    $VER_INFO = "-DmDB_Prefix_t=${PREFIX} -DmDB_Hash_t=${HASH}" ;
+
+    print <<EOM if 0 ;
+    INCLUDE	[$INC_DIR]
+    LIB		[$LIB_DIR]
+    HASH	[$HASH]
+    PREFIX	[$PREFIX]
+    DBNAME      [$DB_NAME]
+
+EOM
+
+    print "Looks Good.\n" ;
+
+}
+
+sub UpDowngrade
+{
+    my @files = @_ ;
+
+    # our      is stable from 5.6.0 onward
+    # warnings is stable from 5.6.1 onward
+
+    # Note: this code assumes that each statement it modifies is not
+    #       split across multiple lines.
+
+
+    my $warn_sub ;
+    my $our_sub ;
+
+    if ($] < 5.006001) {
+        # From: use|no warnings "blah"
+        # To:   local ($^W) = 1; # use|no warnings "blah"
+        #
+        # and
+        #
+        # From: warnings::warnif(x,y);
+        # To:   $^W && carp(y); # warnif -- x
+        $warn_sub = sub {
+	    s/^(\s*)(no\s+warnings)/${1}local (\$^W) = 0; #$2/ ;
+	    s/^(\s*)(use\s+warnings)/${1}local (\$^W) = 1; #$2/ ;
+
+	    s/^(\s*)warnings::warnif\s*\((.*?)\s*,\s*(.*?)\)\s*;/${1}\$^W && carp($3); # warnif - $2/ ;
+          };
+    }
+    else {
+        # From: local ($^W) = 1; # use|no warnings "blah"
+        # To:   use|no warnings "blah"
+        #
+        # and
+        #
+        # From: $^W && carp(y); # warnif -- x
+        # To:   warnings::warnif(x,y);
+        $warn_sub = sub {
+	    s/^(\s*)local\s*\(\$\^W\)\s*=\s*\d+\s*;\s*#\s*((no|use)\s+warnings.*)/$1$2/ ;
+	    s/^(\s*)\$\^W\s+\&\&\s*carp\s*\((.*?)\)\s*;\s*#\s*warnif\s*-\s*(.*)/${1}warnings::warnif($3, $2);/ ;
+          };
+    }
+
+    if ($] < 5.006000) {
+        $our_sub = sub {
+	    if ( /^(\s*)our\s+\(\s*([^)]+\s*)\)/ ) {
+                my $indent = $1;
+                my $vars = join ' ', split /\s*,\s*/, $2;
+                $_ = "${indent}use vars qw($vars);\n";
+            }
+          };
+    }
+    else {
+        $our_sub = sub {
+	    if ( /^(\s*)use\s+vars\s+qw\((.*?)\)/ ) {
+                my $indent = $1;
+                my $vars = join ', ', split ' ', $2;
+                $_ = "${indent}our ($vars);\n";
+            }
+          };
+    }
+
+    foreach (@files)
+      { doUpDown($our_sub, $warn_sub, $_) }
+}
+
+
+sub doUpDown
+{
+    my $our_sub = shift;
+    my $warn_sub = shift;
+
+    local ($^I) = ".bak" ;
+    local (@ARGV) = shift;
+
+    while (<>)
+    {
+	print, last if /^__(END|DATA)__/ ;
+
+	&{ $our_sub }();
+	&{ $warn_sub }();
+	print ;
+    }
+
+    return if eof ;
+
+    while (<>)
+      { print }
+}
+
+# end of file Makefile.PL
diff -ru perl5.005.orig/ext/DB_File/typemap perl5.005/ext/DB_File/typemap
--- perl5.005.orig/ext/DB_File/typemap	2008-09-19 02:43:48.000000000 +0100
+++ perl5.005/ext/DB_File/typemap	2004-01-13 20:16:02.000000000 +0000
@@ -1,8 +1,8 @@
 # typemap for Perl 5 interface to Berkeley 
 #
-# written by Paul Marquess (pmarquess@bfsec.bt.co.uk)
-# last modified 13th May 1998
-# version 1.59
+# written by Paul Marquess <Paul.Marquess@btinternet.com>
+# last modified 10th December 2000
+# version 1.74
 #
 #################################### DB SECTION
 #
@@ -15,21 +15,26 @@
 
 INPUT
 T_dbtkeydatum
-	if (db->type != DB_RECNO) {
+	DBM_ckFilter($arg, filter_store_key, \"filter_store_key\");
+	DBT_clear($var) ;
+	if (SvOK($arg)){
+	    if (db->type != DB_RECNO) {
+	        $var.data = SvPV($arg, PL_na);
+	        $var.size = (int)PL_na;
+	    }
+	    else {
+	        Value =  GetRecnoKey(aTHX_ db, SvIV($arg)) ; 
+	        $var.data = & Value; 
+	        $var.size = (int)sizeof(recno_t);
+	    }
+	}
+T_dbtdatum
+	DBM_ckFilter($arg, filter_store_value, \"filter_store_value\");
+	DBT_clear($var) ;
+	if (SvOK($arg)) {
 	    $var.data = SvPV($arg, PL_na);
 	    $var.size = (int)PL_na;
-	    DBT_flags($var);
 	}
-	else {
-	    Value =  GetRecnoKey(db, SvIV($arg)) ; 
-	    $var.data = & Value; 
-	    $var.size = (int)sizeof(recno_t);
-	    DBT_flags($var);
-	}
-T_dbtdatum
-	$var.data = SvPV($arg, PL_na);
-	$var.size = (int)PL_na;
-	DBT_flags($var);
 
 OUTPUT
 
diff -ru perl5.005.orig/hints/linux.sh perl5.005/hints/linux.sh
--- perl5.005.orig/hints/linux.sh	2008-09-19 02:43:48.000000000 +0100
+++ perl5.005/hints/linux.sh	2008-09-19 12:53:38.000000000 +0100
@@ -18,6 +18,27 @@
 # No version of Linux supports setuid scripts.
 d_suidsafe='undef'
 
+# Debian and Red Hat, and perhaps other vendors, provide both runtime and
+# development packages for some libraries.  The runtime packages contain shared
+# libraries with version information in their names (e.g., libgdbm.so.1.7.3);
+# the development packages supplement this with versionless shared libraries
+# (e.g., libgdbm.so).
+#
+# If you want to link against such a library, you must install the development
+# version of the package.
+#
+# These packages use a -dev naming convention in both Debian and Red Hat:
+#   libgdbmg1  (non-development version of GNU libc 2-linked GDBM library)
+#   libgdbmg1-dev (development version of GNU libc 2-linked GDBM library)
+# So make sure that for any libraries you wish to link Perl with under
+# Debian or Red Hat you have the -dev packages installed.
+#
+# Some operating systems (e.g., Solaris 2.6) will link to a versioned shared
+# library implicitly.  For example, on Solaris, `ld foo.o -lgdbm' will find an
+# appropriate version of libgdbm, if one is available; Linux, however, doesn't
+# do the implicit mapping.
+ignore_versioned_solibs='y'
+
 # perl goes into the /usr tree.  See the Filesystem Standard
 # available via anonymous FTP at tsx-11.mit.edu in
 # /pub/linux/docs/linux-standards/fsstnd.
diff -ru perl5.005.orig/makedepend.SH perl5.005/makedepend.SH
--- perl5.005.orig/makedepend.SH	2008-09-19 02:43:48.000000000 +0100
+++ perl5.005/makedepend.SH	2008-09-19 12:53:47.000000000 +0100
@@ -103,7 +103,7 @@
     *.y) filebase=`basename $file .y` ;;
     esac
     case "$file" in
-    */*) finc="-I`echo $file | sed 's#/[^/]*$##`" ;;
+    */*) finc="-I`echo $file | sed 's#/[^/]*$##'`" ;;
     *)   finc= ;;
     esac
     $echo "Finding dependencies for $filebase$_o."
@@ -118,14 +118,21 @@
 	-e '}' ) >UU/$file.c
     $cppstdin $finc -I. $cppflags $cppminus <UU/$file.c |
     $sed \
-	-e '/^#.*<stdin>/d' \
-	-e '/^#.*"-"/d' \
-	-e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
-	-e 's/^[	 ]*#[	 ]*line/#/' \
-	-e '/^# *[0-9][0-9]* *[".\/]/!d' \
-	-e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
-	-e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
-	-e 's|: \./|: |' \
+        -e '1d' \
+        -e '/^#.*<stdin>/d' \
+        -e '/^#.*<builtin>/d' \
+        -e '/^#.*<built-in>/d' \
+        -e '/^#.*<command line>/d' \
+        -e '/^#.*<command-line>/d' \
+        -e '/^#.*"-"/d' \
+        -e '/^#.*"\/.*\/"/d' \
+        -e '/: file path prefix .* never used$/d' \
+        -e 's#\.[0-9][0-9]*\.c#'"$file.c#" \
+        -e 's/^[	 ]*#[	 ]*line/#/' \
+        -e '/^# *[0-9][0-9]* *[".\/]/!d' \
+        -e 's/^.*"\(.*\)".*$/'$filebase'\$(OBJ_EXT): \1/' \
+        -e 's/^# *[0-9][0-9]* \(.*\)$/'$filebase'\$(OBJ_EXT): \1/' \
+        -e 's|: \./|: |' \
 	-e 's|\.c\.c|.c|' | \
     $uniq | $sort | $uniq >> .deptmp
 done
diff -ru perl5.005.orig/t/lib/db-btree.t perl5.005/t/lib/db-btree.t
--- perl5.005.orig/t/lib/db-btree.t	2008-09-19 02:43:48.000000000 +0100
+++ perl5.005/t/lib/db-btree.t	2004-02-18 12:36:10.000000000 +0000
@@ -1,18 +1,39 @@
 #!./perl -w
 
 BEGIN {
-    @INC = '../lib' if -d '../lib' ;
-    require Config; import Config;
-    if ($Config{'extensions'} !~ /\bDB_File\b/) {
-	print "1..0\n";
-	exit 0;
+    unless(grep /blib/, @INC) {
+        chdir 't' if -d 't';
+        @INC = '../lib' if -d '../lib';
+    }
+}
+ 
+local ($^W) = 1; #use warnings;
+use strict;
+use Config;
+ 
+BEGIN {
+    if(-d "lib" && -f "TEST") {
+        if ($Config{'extensions'} !~ /\bDB_File\b/ ) {
+            print "1..0 # Skip: DB_File was not built\n";
+            exit 0;
+        }
+    }
+    use DB_File;
+    if ($^O eq 'darwin' && ($DB_File::db_version < 2)) {
+	warn <<EOM;
+#
+# This test is known to crash in Mac OS X versions 10.2 (or earlier)
+# because of the buggy Berkeley DB version included with the OS.
+#
+EOM
     }
 }
 
-use DB_File; 
 use Fcntl;
 
-print "1..102\n";
+print "1..177\n";
+
+unlink glob "__db.*";
 
 sub ok
 {
@@ -38,7 +59,72 @@
     return @a - @b ;
 }
 
-$Dfile = "dbbtree.tmp";
+{
+    package Redirect ;
+    use Symbol ;
+
+    sub new
+    {
+        my $class = shift ;
+        my $filename = shift ;
+	my $fh = gensym ;
+	open ($fh, ">$filename") || die "Cannot open $filename: $!" ;
+	my $real_stdout = select($fh) ;
+	return bless [$fh, $real_stdout ] ;
+
+    }
+    sub DESTROY
+    {
+        my $self = shift ;
+	close $self->[0] ;
+	select($self->[1]) ;
+    }
+}
+
+sub docat
+{ 
+    my $file = shift;
+    local $/ = undef ;
+    open(CAT,$file) || die "Cannot open $file: $!";
+    my $result = <CAT>;
+    close(CAT);
+    $result = normalise($result) ;
+    return $result ;
+}   
+
+sub docat_del
+{ 
+    my $file = shift;
+    my $result = docat($file);
+    unlink $file ;
+    return $result ;
+}   
+
+sub normalise
+{
+    my $data = shift ;
+    $data =~ s#\r\n#\n#g 
+        if $^O eq 'cygwin' ;
+
+    return $data ;
+}
+
+sub safeUntie
+{
+    my $hashref = shift ;
+    my $no_inner = 1;
+    local $SIG{__WARN__} = sub {-- $no_inner } ;
+    untie %$hashref;
+    return $no_inner;
+}
+
+
+
+my $db185mode =  ($DB_File::db_version == 1 && ! $DB_File::db_185_compat) ;
+my $null_keys_allowed = ($DB_File::db_ver < 2.004010 
+				|| $DB_File::db_ver >= 3.1 );
+
+my $Dfile = "dbbtree.tmp";
 unlink $Dfile;
 
 umask(0);
@@ -73,38 +159,39 @@
 $dbh->{maxkeypage} = 1234 ;
 ok(14, $dbh->{maxkeypage} == 1234 );
 
-$dbh->{compare} = 1234 ;
-ok(15, $dbh->{compare} == 1234) ;
-
-$dbh->{prefix} = 1234 ;
-ok(16, $dbh->{prefix} == 1234 );
-
 # Check that an invalid entry is caught both for store & fetch
 eval '$dbh->{fred} = 1234' ;
-ok(17, $@ =~ /^DB_File::BTREEINFO::STORE - Unknown element 'fred' at/ ) ;
-eval '$q = $dbh->{fred}' ;
-ok(18, $@ =~ /^DB_File::BTREEINFO::FETCH - Unknown element 'fred' at/ ) ;
+ok(15, $@ =~ /^DB_File::BTREEINFO::STORE - Unknown element 'fred' at/ ) ;
+eval 'my $q = $dbh->{fred}' ;
+ok(16, $@ =~ /^DB_File::BTREEINFO::FETCH - Unknown element 'fred' at/ ) ;
 
 # Now check the interface to BTREE
 
-ok(19, $X = tie(%h, 'DB_File',$Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE )) ;
+my ($X, %h) ;
+ok(17, $X = tie(%h, 'DB_File',$Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE )) ;
+die "Could not tie: $!" unless $X;
 
-($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
+my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks) = stat($Dfile);
-ok(20, ($mode & 0777) == ($^O eq 'os2' ? 0666 : 0640) || $^O eq 'amigaos' || $^O eq 'MSWin32');
 
+my %noMode = map { $_, 1} qw( amigaos MSWin32 NetWare cygwin ) ;
+
+ok(18, ($mode & 0777) == (($^O eq 'os2' || $^O eq 'MacOS') ? 0666 : 0640)
+   || $noMode{$^O} );
+
+my ($key, $value, $i);
 while (($key,$value) = each(%h)) {
     $i++;
 }
-ok(21, !$i ) ;
+ok(19, !$i ) ;
 
 $h{'goner1'} = 'snork';
 
 $h{'abc'} = 'ABC';
-ok(22, $h{'abc'} eq 'ABC' );
-ok(23, ! defined $h{'jimmy'} ) ;
-ok(24, ! exists $h{'jimmy'} ) ;
-ok(25,  defined $h{'abc'} ) ;
+ok(20, $h{'abc'} eq 'ABC' );
+ok(21, ! defined $h{'jimmy'} ) ;
+ok(22, ! exists $h{'jimmy'} ) ;
+ok(23,  defined $h{'abc'} ) ;
 
 $h{'def'} = 'DEF';
 $h{'jkl','mno'} = "JKL\034MNO";
@@ -134,9 +221,8 @@
 undef $X ;
 untie(%h);
 
-
 # tie to the same file again
-ok(26, $X = tie(%h,'DB_File',$Dfile, O_RDWR, 0640, $DB_BTREE)) ;
+ok(24, $X = tie(%h,'DB_File',$Dfile, O_RDWR, 0640, $DB_BTREE)) ;
 
 # Modify an entry from the previous tie
 $h{'g'} = 'G';
@@ -164,10 +250,10 @@
 delete $h{'goner1'};
 $X->DELETE('goner3');
 
-@keys = keys(%h);
-@values = values(%h);
+my @keys = keys(%h);
+my @values = values(%h);
 
-ok(27, $#keys == 29 && $#values == 29) ;
+ok(25, $#keys == 29 && $#values == 29) ;
 
 $i = 0 ;
 while (($key,$value) = each(%h)) {
@@ -177,36 +263,43 @@
     }
 }
 
-ok(28, $i == 30) ;
+ok(26, $i == 30) ;
 
 @keys = ('blurfl', keys(%h), 'dyick');
-ok(29, $#keys == 31) ;
+ok(27, $#keys == 31) ;
 
 #Check that the keys can be retrieved in order
 my @b = keys %h ;
 my @c = sort lexical @b ;
-ok(30, ArrayCompare(\@b, \@c)) ;
+ok(28, ArrayCompare(\@b, \@c)) ;
 
 $h{'foo'} = '';
-ok(31, $h{'foo'} eq '' ) ;
+ok(29, $h{'foo'} eq '' ) ;
 
-#$h{''} = 'bar';
-#ok(32, $h{''} eq 'bar' );
-ok(32,1) ;
+# Berkeley DB from version 2.4.10 to 3.0 does not allow null keys.
+# This feature was reenabled in version 3.1 of Berkeley DB.
+my $result = 0 ;
+if ($null_keys_allowed) {
+    $h{''} = 'bar';
+    $result = ( $h{''} eq 'bar' );
+}
+else
+  { $result = 1 }
+ok(30, $result) ;
 
 # check cache overflow and numeric keys and contents
-$ok = 1;
+my $ok = 1;
 for ($i = 1; $i < 200; $i++) { $h{$i + 0} = $i + 0; }
 for ($i = 1; $i < 200; $i++) { $ok = 0 unless $h{$i} == $i; }
-ok(33, $ok);
+ok(31, $ok);
 
 ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks) = stat($Dfile);
-ok(34, $size > 0 );
+ok(32, $size > 0 );
 
 @h{0..200} = 200..400;
-@foo = @h{0..200};
-ok(35, join(':',200..400) eq join(':',@foo) );
+my @foo = @h{0..200};
+ok(33, join(':',200..400) eq join(':',@foo) );
 
 # Now check all the non-tie specific stuff
 
@@ -214,55 +307,58 @@
 # Check R_NOOVERWRITE flag will make put fail when attempting to overwrite
 # an existing record.
  
-$status = $X->put( 'x', 'newvalue', R_NOOVERWRITE) ;
-ok(36, $status == 1 );
+my $status = $X->put( 'x', 'newvalue', R_NOOVERWRITE) ;
+ok(34, $status == 1 );
  
 # check that the value of the key 'x' has not been changed by the 
 # previous test
-ok(37, $h{'x'} eq 'X' );
+ok(35, $h{'x'} eq 'X' );
 
 # standard put
 $status = $X->put('key', 'value') ;
-ok(38, $status == 0 );
+ok(36, $status == 0 );
 
 #check that previous put can be retrieved
 $value = 0 ;
 $status = $X->get('key', $value) ;
-ok(39, $status == 0 );
-ok(40, $value eq 'value' );
+ok(37, $status == 0 );
+ok(38, $value eq 'value' );
 
 # Attempting to delete an existing key should work
 
 $status = $X->del('q') ;
-ok(41, $status == 0 );
-#$status = $X->del('') ;
-#ok(42, $status == 0 );
-ok(42,1) ;
+ok(39, $status == 0 );
+if ($null_keys_allowed) {
+    $status = $X->del('') ;
+} else {
+    $status = 0 ;
+}
+ok(40, $status == 0 );
 
 # Make sure that the key deleted, cannot be retrieved
-ok(43, ! defined $h{'q'}) ;
-ok(44, ! defined $h{''}) ;
+ok(41, ! defined $h{'q'}) ;
+ok(42, ! defined $h{''}) ;
 
 undef $X ;
 untie %h ;
 
-ok(45, $X = tie(%h, 'DB_File',$Dfile, O_RDWR, 0640, $DB_BTREE ));
+ok(43, $X = tie(%h, 'DB_File',$Dfile, O_RDWR, 0640, $DB_BTREE ));
 
 # Attempting to delete a non-existant key should fail
 
 $status = $X->del('joe') ;
-ok(46, $status == 1 );
+ok(44, $status == 1 );
 
 # Check the get interface
 
 # First a non-existing key
 $status = $X->get('aaaa', $value) ;
-ok(47, $status == 1 );
+ok(45, $status == 1 );
 
 # Next an existing key
 $status = $X->get('a', $value) ;
-ok(48, $status == 0 );
-ok(49, $value eq 'A' );
+ok(46, $status == 0 );
+ok(47, $value eq 'A' );
 
 # seq
 # ###
@@ -271,15 +367,15 @@
 $key = 'ke' ;
 $value = '' ;
 $status = $X->seq($key, $value, R_CURSOR) ;
-ok(50, $status == 0 );
-ok(51, $key eq 'key' );
-ok(52, $value eq 'value' );
+ok(48, $status == 0 );
+ok(49, $key eq 'key' );
+ok(50, $value eq 'value' );
 
 # seq when the key does not match
 $key = 'zzz' ;
 $value = '' ;
 $status = $X->seq($key, $value, R_CURSOR) ;
-ok(53, $status == 1 );
+ok(51, $status == 1 );
 
 
 # use seq to set the cursor, then delete the record @ the cursor.
@@ -287,37 +383,37 @@
 $key = 'x' ;
 $value = '' ;
 $status = $X->seq($key, $value, R_CURSOR) ;
-ok(54, $status == 0 );
-ok(55, $key eq 'x' );
-ok(56, $value eq 'X' );
+ok(52, $status == 0 );
+ok(53, $key eq 'x' );
+ok(54, $value eq 'X' );
 $status = $X->del(0, R_CURSOR) ;
-ok(57, $status == 0 );
+ok(55, $status == 0 );
 $status = $X->get('x', $value) ;
-ok(58, $status == 1 );
+ok(56, $status == 1 );
 
 # ditto, but use put to replace the key/value pair.
 $key = 'y' ;
 $value = '' ;
 $status = $X->seq($key, $value, R_CURSOR) ;
-ok(59, $status == 0 );
-ok(60, $key eq 'y' );
-ok(61, $value eq 'Y' );
+ok(57, $status == 0 );
+ok(58, $key eq 'y' );
+ok(59, $value eq 'Y' );
 
 $key = "replace key" ;
 $value = "replace value" ;
 $status = $X->put($key, $value, R_CURSOR) ;
-ok(62, $status == 0 );
-ok(63, $key eq 'replace key' );
-ok(64, $value eq 'replace value' );
+ok(60, $status == 0 );
+ok(61, $key eq 'replace key' );
+ok(62, $value eq 'replace value' );
 $status = $X->get('y', $value) ;
-ok(65, 1) ; # hard-wire to always pass. the previous test ($status == 1)
+ok(63, 1) ; # hard-wire to always pass. the previous test ($status == 1)
 	    # only worked because of a bug in 1.85/6
 
 # use seq to walk forwards through a file 
 
 $status = $X->seq($key, $value, R_FIRST) ;
-ok(66, $status == 0 );
-$previous = $key ;
+ok(64, $status == 0 );
+my $previous = $key ;
 
 $ok = 1 ;
 while (($status = $X->seq($key, $value, R_NEXT)) == 0)
@@ -325,12 +421,12 @@
     ($ok = 0), last if ($previous cmp $key) == 1 ;
 }
 
-ok(67, $status == 1 );
-ok(68, $ok == 1 );
+ok(65, $status == 1 );
+ok(66, $ok == 1 );
 
 # use seq to walk backwards through a file 
 $status = $X->seq($key, $value, R_LAST) ;
-ok(69, $status == 0 );
+ok(67, $status == 0 );
 $previous = $key ;
 
 $ok = 1 ;
@@ -340,8 +436,8 @@
     #print "key = [$key] value = [$value]\n" ;
 }
 
-ok(70, $status == 1 );
-ok(71, $ok == 1 );
+ok(68, $status == 1 );
+ok(69, $ok == 1 );
 
 
 # check seq FIRST/LAST
@@ -350,14 +446,14 @@
 # ####
 
 $status = $X->sync ;
-ok(72, $status == 0 );
+ok(70, $status == 0 );
 
 
 # fd
 # ##
 
 $status = $X->fd ;
-ok(73, $status != 0 );
+ok(71, $status != 0 );
 
 
 undef $X ;
@@ -366,11 +462,12 @@
 unlink $Dfile;
 
 # Now try an in memory file
-ok(74, $Y = tie(%h, 'DB_File',undef, O_RDWR|O_CREAT, 0640, $DB_BTREE ));
+my $Y;
+ok(72, $Y = tie(%h, 'DB_File',undef, O_RDWR|O_CREAT, 0640, $DB_BTREE ));
 
 # fd with an in memory file should return failure
 $status = $Y->fd ;
-ok(75, $status == -1 );
+ok(73, $status == -1 );
 
 
 undef $Y ;
@@ -379,7 +476,8 @@
 # Duplicate keys
 my $bt = new DB_File::BTREEINFO ;
 $bt->{flags} = R_DUP ;
-ok(76, $YY = tie(%hh, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $bt )) ;
+my ($YY, %hh);
+ok(74, $YY = tie(%hh, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $bt )) ;
 
 $hh{'Wall'} = 'Larry' ;
 $hh{'Wall'} = 'Stone' ; # Note the duplicate key
@@ -389,33 +487,33 @@
 $hh{'mouse'} = 'mickey' ;
 
 # first work in scalar context
-ok(77, scalar $YY->get_dup('Unknown') == 0 );
-ok(78, scalar $YY->get_dup('Smith') == 1 );
-ok(79, scalar $YY->get_dup('Wall') == 4 );
+ok(75, scalar $YY->get_dup('Unknown') == 0 );
+ok(76, scalar $YY->get_dup('Smith') == 1 );
+ok(77, scalar $YY->get_dup('Wall') == 4 );
 
 # now in list context
 my @unknown = $YY->get_dup('Unknown') ;
-ok(80, "@unknown" eq "" );
+ok(78, "@unknown" eq "" );
 
 my @smith = $YY->get_dup('Smith') ;
-ok(81, "@smith" eq "John" );
+ok(79, "@smith" eq "John" );
 
 {
 my @wall = $YY->get_dup('Wall') ;
 my %wall ;
 @wall{@wall} = @wall ;
-ok(82, (@wall == 4 && $wall{'Larry'} && $wall{'Stone'} && $wall{'Brick'}) );
+ok(80, (@wall == 4 && $wall{'Larry'} && $wall{'Stone'} && $wall{'Brick'}) );
 }
 
 # hash
 my %unknown = $YY->get_dup('Unknown', 1) ;
-ok(83, keys %unknown == 0 );
+ok(81, keys %unknown == 0 );
 
 my %smith = $YY->get_dup('Smith', 1) ;
-ok(84, keys %smith == 1 && $smith{'John'}) ;
+ok(82, keys %smith == 1 && $smith{'John'}) ;
 
 my %wall = $YY->get_dup('Wall', 1) ;
-ok(85, keys %wall == 3 && $wall{'Larry'} == 1 && $wall{'Stone'} == 1 
+ok(83, keys %wall == 3 && $wall{'Larry'} == 1 && $wall{'Stone'} == 1 
 		&& $wall{'Brick'} == 2);
 
 undef $YY ;
@@ -424,34 +522,38 @@
 
 
 # test multiple callbacks
-$Dfile1 = "btree1" ;
-$Dfile2 = "btree2" ;
-$Dfile3 = "btree3" ;
- 
-$dbh1 = new DB_File::BTREEINFO ;
-{ local $^W = 0 ;
-  $dbh1->{compare} = sub { $_[0] <=> $_[1] } ; }
+my $Dfile1 = "btree1" ;
+my $Dfile2 = "btree2" ;
+my $Dfile3 = "btree3" ;
+ 
+my $dbh1 = new DB_File::BTREEINFO ;
+$dbh1->{compare} = sub { 
+	local ($^W) = 0; #no warnings 'numeric' ;
+	$_[0] <=> $_[1] } ; 
  
-$dbh2 = new DB_File::BTREEINFO ;
+my $dbh2 = new DB_File::BTREEINFO ;
 $dbh2->{compare} = sub { $_[0] cmp $_[1] } ;
  
-$dbh3 = new DB_File::BTREEINFO ;
+my $dbh3 = new DB_File::BTREEINFO ;
 $dbh3->{compare} = sub { length $_[0] <=> length $_[1] } ;
  
  
-tie(%h, 'DB_File',$Dfile1, O_RDWR|O_CREAT, 0640, $dbh1 ) ;
-tie(%g, 'DB_File',$Dfile2, O_RDWR|O_CREAT, 0640, $dbh2 ) ;
-tie(%k, 'DB_File',$Dfile3, O_RDWR|O_CREAT, 0640, $dbh3 ) ;
- 
-@Keys = qw( 0123 12 -1234 9 987654321 def  ) ;
-{ local $^W = 0 ;
-  @srt_1 = sort { $a <=> $b } @Keys ; }
+my (%g, %k);
+tie(%h, 'DB_File',$Dfile1, O_RDWR|O_CREAT, 0640, $dbh1 ) or die $!;
+tie(%g, 'DB_File',$Dfile2, O_RDWR|O_CREAT, 0640, $dbh2 ) or die $!;
+tie(%k, 'DB_File',$Dfile3, O_RDWR|O_CREAT, 0640, $dbh3 ) or die $!;
+ 
+my @Keys = qw( 0123 12 -1234 9 987654321 def  ) ;
+my (@srt_1, @srt_2, @srt_3);
+{ 
+  local ($^W) = 0; #no warnings 'numeric' ;
+  @srt_1 = sort { $a <=> $b } @Keys ; 
+}
 @srt_2 = sort { $a cmp $b } @Keys ;
 @srt_3 = sort { length $a <=> length $b } @Keys ;
  
 foreach (@Keys) {
-    { local $^W = 0 ; 
-      $h{$_} = 1 ; }
+    $h{$_} = 1 ;
     $g{$_} = 1 ;
     $k{$_} = 1 ;
 }
@@ -470,9 +572,9 @@
     1 ;
 }
  
-ok(86, ArrayCompare (\@srt_1, [keys %h]) );
-ok(87, ArrayCompare (\@srt_2, [keys %g]) );
-ok(88, ArrayCompare (\@srt_3, [keys %k]) );
+ok(84, ArrayCompare (\@srt_1, [keys %h]) );
+ok(85, ArrayCompare (\@srt_2, [keys %g]) );
+ok(86, ArrayCompare (\@srt_3, [keys %k]) );
 
 untie %h ;
 untie %g ;
@@ -482,7 +584,7 @@
 # clear
 # #####
 
-ok(89, tie(%h, 'DB_File', $Dfile1, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );
+ok(87, tie(%h, 'DB_File', $Dfile1, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );
 foreach (1 .. 10)
   { $h{$_} = $_ * 100 }
 
@@ -491,7 +593,7 @@
 while (($key,$value) = each(%h)) {
     $i++;
 }
-ok(90, $i == 10);
+ok(88, $i == 10);
 
 # now clear the hash
 %h = () ;
@@ -501,7 +603,7 @@
 while (($key,$value) = each(%h)) {
     $i++;
 }
-ok(91, $i == 0);
+ok(89, $i == 0);
 
 untie %h ;
 unlink $Dfile1 ;
@@ -512,7 +614,7 @@
     my $filename = "xyz" ;
     my @x ;
     eval { tie @x, 'DB_File', $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE ; } ;
-    ok(92, $@ =~ /^DB_File can only tie an associative array to a DB_BTREE database/) ;
+    ok(90, $@ =~ /^DB_File can only tie an associative array to a DB_BTREE database/) ;
     unlink $filename ;
 }
 
@@ -521,6 +623,7 @@
 
    package Another ;
 
+   local ($^W) = 1; #use warnings ;
    use strict ;
 
    open(FILE, ">SubDB.pm") or die "Cannot open SubDB.pm: $!\n" ;
@@ -528,8 +631,9 @@
 
    package SubDB ;
 
+   local ($^W) = 1; #use warnings ;
    use strict ;
-   use vars qw( @ISA @EXPORT) ;
+   use vars qw(@ISA @EXPORT);
 
    require Exporter ;
    use DB_File;
@@ -577,31 +681,31 @@
 
     BEGIN { push @INC, '.'; }    
     eval 'use SubDB ; ';
-    main::ok(93, $@ eq "") ;
+    main::ok(91, $@ eq "") ;
     my %h ;
     my $X ;
     eval '
 	$X = tie(%h, "SubDB","dbbtree.tmp", O_RDWR|O_CREAT, 0640, $DB_BTREE );
 	' ;
 
-    main::ok(94, $@ eq "") ;
+    main::ok(92, $@ eq "") ;
 
     my $ret = eval '$h{"fred"} = 3 ; return $h{"fred"} ' ;
-    main::ok(95, $@ eq "") ;
-    main::ok(96, $ret == 5) ;
+    main::ok(93, $@ eq "") ;
+    main::ok(94, $ret == 5) ;
 
     my $value = 0;
     $ret = eval '$X->put("joe", 4) ; $X->get("joe", $value) ; return $value' ;
-    main::ok(97, $@ eq "") ;
-    main::ok(98, $ret == 10) ;
+    main::ok(95, $@ eq "") ;
+    main::ok(96, $ret == 10) ;
 
     $ret = eval ' R_NEXT eq main::R_NEXT ' ;
-    main::ok(99, $@ eq "" ) ;
-    main::ok(100, $ret == 1) ;
+    main::ok(97, $@ eq "" ) ;
+    main::ok(98, $ret == 1) ;
 
     $ret = eval '$X->A_new_method("joe") ' ;
-    main::ok(101, $@ eq "") ;
-    main::ok(102, $ret eq "[[11]]") ;
+    main::ok(99, $@ eq "") ;
+    main::ok(100, $ret eq "[[11]]") ;
 
     undef $X;
     untie(%h);
@@ -609,4 +713,778 @@
 
 }
 
+{
+   # DBM Filter tests
+   local ($^W) = 1; #use warnings ;
+   use strict ;
+   my (%h, $db) ;
+   my ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   unlink $Dfile;
+
+   sub checkOutput
+   {
+       my($fk, $sk, $fv, $sv) = @_ ;
+       return
+           $fetch_key eq $fk && $store_key eq $sk && 
+	   $fetch_value eq $fv && $store_value eq $sv &&
+	   $_ eq 'original' ;
+   }
+   
+   ok(101, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );
+
+   $db->filter_fetch_key   (sub { $fetch_key = $_ }) ;
+   $db->filter_store_key   (sub { $store_key = $_ }) ;
+   $db->filter_fetch_value (sub { $fetch_value = $_}) ;
+   $db->filter_store_value (sub { $store_value = $_ }) ;
+
+   $_ = "original" ;
+
+   $h{"fred"} = "joe" ;
+   #                   fk   sk     fv   sv
+   ok(102, checkOutput( "", "fred", "", "joe")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(103, $h{"fred"} eq "joe");
+   #                   fk    sk     fv    sv
+   ok(104, checkOutput( "", "fred", "joe", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(105, $db->FIRSTKEY() eq "fred") ;
+   #                    fk     sk  fv  sv
+   ok(106, checkOutput( "fred", "", "", "")) ;
+
+   # replace the filters, but remember the previous set
+   my ($old_fk) = $db->filter_fetch_key   
+   			(sub { $_ = uc $_ ; $fetch_key = $_ }) ;
+   my ($old_sk) = $db->filter_store_key   
+   			(sub { $_ = lc $_ ; $store_key = $_ }) ;
+   my ($old_fv) = $db->filter_fetch_value 
+   			(sub { $_ = "[$_]"; $fetch_value = $_ }) ;
+   my ($old_sv) = $db->filter_store_value 
+   			(sub { s/o/x/g; $store_value = $_ }) ;
+   
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   $h{"Fred"} = "Joe" ;
+   #                   fk   sk     fv    sv
+   ok(107, checkOutput( "", "fred", "", "Jxe")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(108, $h{"Fred"} eq "[Jxe]");
+   #                   fk   sk     fv    sv
+   ok(109, checkOutput( "", "fred", "[Jxe]", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(110, $db->FIRSTKEY() eq "FRED") ;
+   #                   fk   sk     fv    sv
+   ok(111, checkOutput( "FRED", "", "", "")) ;
+
+   # put the original filters back
+   $db->filter_fetch_key   ($old_fk);
+   $db->filter_store_key   ($old_sk);
+   $db->filter_fetch_value ($old_fv);
+   $db->filter_store_value ($old_sv);
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   $h{"fred"} = "joe" ;
+   ok(112, checkOutput( "", "fred", "", "joe")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(113, $h{"fred"} eq "joe");
+   ok(114, checkOutput( "", "fred", "joe", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(115, $db->FIRSTKEY() eq "fred") ;
+   ok(116, checkOutput( "fred", "", "", "")) ;
+
+   # delete the filters
+   $db->filter_fetch_key   (undef);
+   $db->filter_store_key   (undef);
+   $db->filter_fetch_value (undef);
+   $db->filter_store_value (undef);
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   $h{"fred"} = "joe" ;
+   ok(117, checkOutput( "", "", "", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(118, $h{"fred"} eq "joe");
+   ok(119, checkOutput( "", "", "", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(120, $db->FIRSTKEY() eq "fred") ;
+   ok(121, checkOutput( "", "", "", "")) ;
+
+   undef $db ;
+   untie %h;
+   unlink $Dfile;
+}
+
+{    
+    # DBM Filter with a closure
+
+    local ($^W) = 1; #use warnings ;
+    use strict ;
+    my (%h, $db) ;
+
+    unlink $Dfile;
+    ok(122, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );
+
+    my %result = () ;
+
+    sub Closure
+    {
+        my ($name) = @_ ;
+	my $count = 0 ;
+	my @kept = () ;
+
+	return sub { ++$count ; 
+		     push @kept, $_ ; 
+		     $result{$name} = "$name - $count: [@kept]" ;
+		   }
+    }
+
+    $db->filter_store_key(Closure("store key")) ;
+    $db->filter_store_value(Closure("store value")) ;
+    $db->filter_fetch_key(Closure("fetch key")) ;
+    $db->filter_fetch_value(Closure("fetch value")) ;
+
+    $_ = "original" ;
+
+    $h{"fred"} = "joe" ;
+    ok(123, $result{"store key"} eq "store key - 1: [fred]");
+    ok(124, $result{"store value"} eq "store value - 1: [joe]");
+    ok(125, ! defined $result{"fetch key"} );
+    ok(126, ! defined $result{"fetch value"} );
+    ok(127, $_ eq "original") ;
+
+    ok(128, $db->FIRSTKEY() eq "fred") ;
+    ok(129, $result{"store key"} eq "store key - 1: [fred]");
+    ok(130, $result{"store value"} eq "store value - 1: [joe]");
+    ok(131, $result{"fetch key"} eq "fetch key - 1: [fred]");
+    ok(132, ! defined $result{"fetch value"} );
+    ok(133, $_ eq "original") ;
+
+    $h{"jim"}  = "john" ;
+    ok(134, $result{"store key"} eq "store key - 2: [fred jim]");
+    ok(135, $result{"store value"} eq "store value - 2: [joe john]");
+    ok(136, $result{"fetch key"} eq "fetch key - 1: [fred]");
+    ok(137, ! defined $result{"fetch value"} );
+    ok(138, $_ eq "original") ;
+
+    ok(139, $h{"fred"} eq "joe");
+    ok(140, $result{"store key"} eq "store key - 3: [fred jim fred]");
+    ok(141, $result{"store value"} eq "store value - 2: [joe john]");
+    ok(142, $result{"fetch key"} eq "fetch key - 1: [fred]");
+    ok(143, $result{"fetch value"} eq "fetch value - 1: [joe]");
+    ok(144, $_ eq "original") ;
+
+    undef $db ;
+    untie %h;
+    unlink $Dfile;
+}		
+
+{
+   # DBM Filter recursion detection
+   local ($^W) = 1; #use warnings ;
+   use strict ;
+   my (%h, $db) ;
+   unlink $Dfile;
+
+   ok(145, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );
+
+   $db->filter_store_key (sub { $_ = $h{$_} }) ;
+
+   eval '$h{1} = 1234' ;
+   ok(146, $@ =~ /^recursion detected in filter_store_key at/ );
+   
+   undef $db ;
+   untie %h;
+   unlink $Dfile;
+}
+
+
+{
+   # Examples from the POD
+
+
+  my $file = "xyzt" ;
+  {
+    my $redirect = new Redirect $file ;
+
+    # BTREE example 1
+    ###
+
+    local ($^W) = 1; #use warnings FATAL => qw(all) ;
+    use strict ;
+    use DB_File ;
+
+    my %h ;
+
+    sub Compare
+    {
+        my ($key1, $key2) = @_ ;
+        "\L$key1" cmp "\L$key2" ;
+    }
+
+    # specify the Perl sub that will do the comparison
+    $DB_BTREE->{'compare'} = \&Compare ;
+
+    unlink "tree" ;
+    tie %h, "DB_File", "tree", O_RDWR|O_CREAT, 0640, $DB_BTREE 
+        or die "Cannot open file 'tree': $!\n" ;
+
+    # Add a key/value pair to the file
+    $h{'Wall'} = 'Larry' ;
+    $h{'Smith'} = 'John' ;
+    $h{'mouse'} = 'mickey' ;
+    $h{'duck'}  = 'donald' ;
+
+    # Delete
+    delete $h{"duck"} ;
+
+    # Cycle through the keys printing them in order.
+    # Note it is not necessary to sort the keys as
+    # the btree will have kept them in order automatically.
+    foreach (keys %h)
+      { print "$_\n" }
+
+    untie %h ;
+
+    unlink "tree" ;
+  }  
+
+  delete $DB_BTREE->{'compare'} ;
+
+  ok(147, docat_del($file) eq <<'EOM') ;
+mouse
+Smith
+Wall
+EOM
+   
+  {
+    my $redirect = new Redirect $file ;
+
+    # BTREE example 2
+    ###
+
+    local ($^W) = 1; #use warnings FATAL => qw(all) ;
+    use strict ;
+    use DB_File ;
+
+    my ($filename, %h);
+
+    $filename = "tree" ;
+    unlink $filename ;
+ 
+    # Enable duplicate records
+    $DB_BTREE->{'flags'} = R_DUP ;
+ 
+    tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
+	or die "Cannot open $filename: $!\n";
+ 
+    # Add some key/value pairs to the file
+    $h{'Wall'} = 'Larry' ;
+    $h{'Wall'} = 'Brick' ; # Note the duplicate key
+    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
+    $h{'Smith'} = 'John' ;
+    $h{'mouse'} = 'mickey' ;
+
+    # iterate through the associative array
+    # and print each key/value pair.
+    foreach (keys %h)
+      { print "$_	-> $h{$_}\n" }
+
+    untie %h ;
+
+    unlink $filename ;
+  }  
+
+  ok(148, docat_del($file) eq ($db185mode ? <<'EOM' : <<'EOM') ) ;
+Smith	-> John
+Wall	-> Brick
+Wall	-> Brick
+Wall	-> Brick
+mouse	-> mickey
+EOM
+Smith	-> John
+Wall	-> Larry
+Wall	-> Larry
+Wall	-> Larry
+mouse	-> mickey
+EOM
+
+  {
+    my $redirect = new Redirect $file ;
+
+    # BTREE example 3
+    ###
+
+    local ($^W) = 1; #use warnings FATAL => qw(all) ;
+    use strict ;
+    use DB_File ;
+ 
+    my ($filename, $x, %h, $status, $key, $value);
+
+    $filename = "tree" ;
+    unlink $filename ;
+ 
+    # Enable duplicate records
+    $DB_BTREE->{'flags'} = R_DUP ;
+ 
+    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
+	or die "Cannot open $filename: $!\n";
+ 
+    # Add some key/value pairs to the file
+    $h{'Wall'} = 'Larry' ;
+    $h{'Wall'} = 'Brick' ; # Note the duplicate key
+    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value
+    $h{'Smith'} = 'John' ;
+    $h{'mouse'} = 'mickey' ;
+ 
+    # iterate through the btree using seq
+    # and print each key/value pair.
+    $key = $value = 0 ;
+    for ($status = $x->seq($key, $value, R_FIRST) ;
+         $status == 0 ;
+         $status = $x->seq($key, $value, R_NEXT) )
+      {  print "$key	-> $value\n" }
+ 
+ 
+    undef $x ;
+    untie %h ;
+  }
+
+  ok(149, docat_del($file) eq ($db185mode == 1 ? <<'EOM' : <<'EOM') ) ;
+Smith	-> John
+Wall	-> Brick
+Wall	-> Brick
+Wall	-> Larry
+mouse	-> mickey
+EOM
+Smith	-> John
+Wall	-> Larry
+Wall	-> Brick
+Wall	-> Brick
+mouse	-> mickey
+EOM
+
+
+  {
+    my $redirect = new Redirect $file ;
+
+    # BTREE example 4
+    ###
+
+    local ($^W) = 1; #use warnings FATAL => qw(all) ;
+    use strict ;
+    use DB_File ;
+ 
+    my ($filename, $x, %h);
+
+    $filename = "tree" ;
+ 
+    # Enable duplicate records
+    $DB_BTREE->{'flags'} = R_DUP ;
+ 
+    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
+	or die "Cannot open $filename: $!\n";
+ 
+    my $cnt  = $x->get_dup("Wall") ;
+    print "Wall occurred $cnt times\n" ;
+
+    my %hash = $x->get_dup("Wall", 1) ;
+    print "Larry is there\n" if $hash{'Larry'} ;
+    print "There are $hash{'Brick'} Brick Walls\n" ;
+
+    my @list = sort $x->get_dup("Wall") ;
+    print "Wall =>	[@list]\n" ;
+
+    @list = $x->get_dup("Smith") ;
+    print "Smith =>	[@list]\n" ;
+ 
+    @list = $x->get_dup("Dog") ;
+    print "Dog =>	[@list]\n" ; 
+ 
+    undef $x ;
+    untie %h ;
+  }
+
+  ok(150, docat_del($file) eq <<'EOM') ;
+Wall occurred 3 times
+Larry is there
+There are 2 Brick Walls
+Wall =>	[Brick Brick Larry]
+Smith =>	[John]
+Dog =>	[]
+EOM
+
+  {
+    my $redirect = new Redirect $file ;
+
+    # BTREE example 5
+    ###
+
+    local ($^W) = 1; #use warnings FATAL => qw(all) ;
+    use strict ;
+    use DB_File ;
+ 
+    my ($filename, $x, %h, $found);
+
+    $filename = "tree" ;
+ 
+    # Enable duplicate records
+    $DB_BTREE->{'flags'} = R_DUP ;
+ 
+    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
+	or die "Cannot open $filename: $!\n";
+
+    $found = ( $x->find_dup("Wall", "Larry") == 0 ? "" : "not") ; 
+    print "Larry Wall is $found there\n" ;
+    
+    $found = ( $x->find_dup("Wall", "Harry") == 0 ? "" : "not") ; 
+    print "Harry Wall is $found there\n" ;
+    
+    undef $x ;
+    untie %h ;
+  }
+
+  ok(151, docat_del($file) eq <<'EOM') ;
+Larry Wall is  there
+Harry Wall is not there
+EOM
+
+  {
+    my $redirect = new Redirect $file ;
+
+    # BTREE example 6
+    ###
+
+    local ($^W) = 1; #use warnings FATAL => qw(all) ;
+    use strict ;
+    use DB_File ;
+ 
+    my ($filename, $x, %h, $found);
+
+    $filename = "tree" ;
+ 
+    # Enable duplicate records
+    $DB_BTREE->{'flags'} = R_DUP ;
+ 
+    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE 
+	or die "Cannot open $filename: $!\n";
+
+    $x->del_dup("Wall", "Larry") ;
+
+    $found = ( $x->find_dup("Wall", "Larry") == 0 ? "" : "not") ; 
+    print "Larry Wall is $found there\n" ;
+    
+    undef $x ;
+    untie %h ;
+
+    unlink $filename ;
+  }
+
+  ok(152, docat_del($file) eq <<'EOM') ;
+Larry Wall is not there
+EOM
+
+  {
+    my $redirect = new Redirect $file ;
+
+    # BTREE example 7
+    ###
+
+    local ($^W) = 1; #use warnings FATAL => qw(all) ;
+    use strict ;
+    use DB_File ;
+    use Fcntl ;
+
+    my ($filename, $x, %h, $st, $key, $value);
+
+    sub match
+    {
+        my $key = shift ;
+        my $value = 0;
+        my $orig_key = $key ;
+        $x->seq($key, $value, R_CURSOR) ;
+        print "$orig_key\t-> $key\t-> $value\n" ;
+    }
+
+    $filename = "tree" ;
+    unlink $filename ;
+
+    $x = tie %h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_BTREE
+        or die "Cannot open $filename: $!\n";
+ 
+    # Add some key/value pairs to the file
+    $h{'mouse'} = 'mickey' ;
+    $h{'Wall'} = 'Larry' ;
+    $h{'Walls'} = 'Brick' ; 
+    $h{'Smith'} = 'John' ;
+ 
+
+    $key = $value = 0 ;
+    print "IN ORDER\n" ;
+    for ($st = $x->seq($key, $value, R_FIRST) ;
+	 $st == 0 ;
+         $st = $x->seq($key, $value, R_NEXT) )
+	
+      {  print "$key	-> $value\n" }
+ 
+    print "\nPARTIAL MATCH\n" ;
+
+    match "Wa" ;
+    match "A" ;
+    match "a" ;
+
+    undef $x ;
+    untie %h ;
+
+    unlink $filename ;
+
+  }
+
+  ok(153, docat_del($file) eq <<'EOM') ;
+IN ORDER
+Smith	-> John
+Wall	-> Larry
+Walls	-> Brick
+mouse	-> mickey
+
+PARTIAL MATCH
+Wa	-> Wall	-> Larry
+A	-> Smith	-> John
+a	-> mouse	-> mickey
+EOM
+
+}
+
+#{
+#   # R_SETCURSOR
+#   use strict ;
+#   my (%h, $db) ;
+#   unlink $Dfile;
+#
+#   ok(156, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );
+#
+#   $h{abc} = 33 ;
+#   my $k = "newest" ;
+#   my $v = 44 ;
+#   my $status = $db->put($k, $v, R_SETCURSOR) ;
+#   print "status = [$status]\n" ;
+#   ok(157, $status == 0) ;
+#   $status = $db->del($k, R_CURSOR) ;
+#   print "status = [$status]\n" ;
+#   ok(158, $status == 0) ;
+#   $k = "newest" ;
+#   ok(159, $db->get($k, $v, R_CURSOR)) ;
+#
+#   ok(160, keys %h == 1) ;
+#   
+#   undef $db ;
+#   untie %h;
+#   unlink $Dfile;
+#}
+
+{
+    # Bug ID 20001013.009
+    #
+    # test that $hash{KEY} = undef doesn't produce the warning
+    #     Use of uninitialized value in null operation 
+    local ($^W) = 1; #use warnings ;
+    use strict ;
+    use DB_File ;
+
+    unlink $Dfile;
+    my %h ;
+    my $a = "";
+    local $SIG{__WARN__} = sub {$a = $_[0]} ;
+    
+    tie %h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0664, $DB_BTREE
+	or die "Can't open file: $!\n" ;
+    $h{ABC} = undef;
+    ok(154, $a eq "") ;
+    untie %h ;
+    unlink $Dfile;
+}
+
+{
+    # test that %hash = () doesn't produce the warning
+    #     Argument "" isn't numeric in entersub
+    local ($^W) = 1; #use warnings ;
+    use strict ;
+    use DB_File ;
+
+    unlink $Dfile;
+    my %h ;
+    my $a = "";
+    local $SIG{__WARN__} = sub {$a = $_[0]} ;
+    
+    tie %h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0664, $DB_BTREE
+	or die "Can't open file: $!\n" ;
+    %h = (); ;
+    ok(155, $a eq "") ;
+    untie %h ;
+    unlink $Dfile;
+}
+
+{
+    # When iterating over a tied hash using "each", the key passed to FETCH
+    # will be recycled and passed to NEXTKEY. If a Source Filter modifies the
+    # key in FETCH via a filter_fetch_key method we need to check that the
+    # modified key doesn't get passed to NEXTKEY.
+    # Also Test "keys" & "values" while we are at it.
+
+    local ($^W) = 1; #use warnings ;
+    use strict ;
+    use DB_File ;
+
+    unlink $Dfile;
+    my $bad_key = 0 ;
+    my %h = () ;
+    my $db ;
+    ok(156, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );
+    $db->filter_fetch_key (sub { $_ =~ s/^Beta_/Alpha_/ if defined $_}) ;
+    $db->filter_store_key (sub { $bad_key = 1 if /^Beta_/ ; $_ =~ s/^Alpha_/Beta_/}) ;
+
+    $h{'Alpha_ABC'} = 2 ;
+    $h{'Alpha_DEF'} = 5 ;
+
+    ok(157, $h{'Alpha_ABC'} == 2);
+    ok(158, $h{'Alpha_DEF'} == 5);
+
+    my ($k, $v) = ("","");
+    while (($k, $v) = each %h) {}
+    ok(159, $bad_key == 0);
+
+    $bad_key = 0 ;
+    foreach $k (keys %h) {}
+    ok(160, $bad_key == 0);
+
+    $bad_key = 0 ;
+    foreach $v (values %h) {}
+    ok(161, $bad_key == 0);
+
+    undef $db ;
+    untie %h ;
+    unlink $Dfile;
+}
+
+{
+    # now an error to pass 'compare' a non-code reference
+    my $dbh = new DB_File::BTREEINFO ;
+
+    eval { $dbh->{compare} = 2 };
+    ok(162, $@ =~ /^Key 'compare' not associated with a code reference at/);
+
+    eval { $dbh->{prefix} = 2 };
+    ok(163, $@ =~ /^Key 'prefix' not associated with a code reference at/);
+
+}
+
+
+#{
+#    # recursion detection in btree
+#    my %hash ;
+#    unlink $Dfile;
+#    my $dbh = new DB_File::BTREEINFO ;
+#    $dbh->{compare} = sub { $hash{3} = 4 ; length $_[0] } ;
+# 
+# 
+#    my (%h);
+#    ok(164, tie(%hash, 'DB_File',$Dfile, O_RDWR|O_CREAT, 0640, $dbh ) );
+#
+#    eval {	$hash{1} = 2;
+#    		$hash{4} = 5;
+#	 };
+#
+#    ok(165, $@ =~ /^DB_File btree_compare: recursion detected/);
+#    {
+#        no warnings;
+#        untie %hash;
+#    }
+#    unlink $Dfile;
+#}
+ok(164,1);
+ok(165,1);
+
+{
+    # Check that two callbacks don't interact
+    my %hash1 ;
+    my %hash2 ;
+    my $h1_count = 0;
+    my $h2_count = 0;
+    unlink $Dfile, $Dfile2;
+    my $dbh1 = new DB_File::BTREEINFO ;
+    $dbh1->{compare} = sub { ++ $h1_count ; $_[0] cmp $_[1] } ; 
+
+    my $dbh2 = new DB_File::BTREEINFO ;
+    $dbh2->{compare} = sub { ;++ $h2_count ; $_[0] cmp $_[1] } ; 
+ 
+ 
+ 
+    my (%h);
+    ok(166, tie(%hash1, 'DB_File',$Dfile, O_RDWR|O_CREAT, 0640, $dbh1 ) );
+    ok(167, tie(%hash2, 'DB_File',$Dfile2, O_RDWR|O_CREAT, 0640, $dbh2 ) );
+
+    $hash1{DEFG} = 5;
+    $hash1{XYZ} = 2;
+    $hash1{ABCDE} = 5;
+
+    $hash2{defg} = 5;
+    $hash2{xyz} = 2;
+    $hash2{abcde} = 5;
+
+    ok(168, $h1_count > 0);
+    ok(169, $h1_count == $h2_count);
+
+    ok(170, safeUntie \%hash1);
+    ok(171, safeUntie \%hash2);
+    unlink $Dfile, $Dfile2;
+}
+
+{
+   # Check that DBM Filter can cope with read-only $_
+
+   local ($^W) = 1; #use warnings ;
+   use strict ;
+   my (%h, $db) ;
+   unlink $Dfile;
+
+   ok(172, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_BTREE ) );
+
+   $db->filter_fetch_key   (sub { }) ;
+   $db->filter_store_key   (sub { }) ;
+   $db->filter_fetch_value (sub { }) ;
+   $db->filter_store_value (sub { }) ;
+
+   $_ = "original" ;
+
+   $h{"fred"} = "joe" ;
+   ok(173, $h{"fred"} eq "joe");
+
+   eval { grep { $h{$_} } (1, 2, 3) };
+   ok (174, ! $@);
+
+
+   # delete the filters
+   $db->filter_fetch_key   (undef);
+   $db->filter_store_key   (undef);
+   $db->filter_fetch_value (undef);
+   $db->filter_store_value (undef);
+
+   $h{"fred"} = "joe" ;
+
+   ok(175, $h{"fred"} eq "joe");
+
+   ok(176, $db->FIRSTKEY() eq "fred") ;
+   
+   eval { grep { $h{$_} } (1, 2, 3) };
+   ok (177, ! $@);
+
+   undef $db ;
+   untie %h;
+   unlink $Dfile;
+}
+
 exit ;
diff -ru perl5.005.orig/t/lib/db-hash.t perl5.005/t/lib/db-hash.t
--- perl5.005.orig/t/lib/db-hash.t	2008-09-19 02:43:48.000000000 +0100
+++ perl5.005/t/lib/db-hash.t	2004-01-13 20:17:22.000000000 +0000
@@ -1,18 +1,31 @@
-#!./perl -w
+#!./perl 
 
 BEGIN {
-    @INC = '../lib' if -d '../lib' ;
-    require Config; import Config;
-    if ($Config{'extensions'} !~ /\bDB_File\b/) {
-	print "1..0\n";
-	exit 0;
+    unless(grep /blib/, @INC) {
+        chdir 't' if -d 't';
+        @INC = '../lib' if -d '../lib';
+    }
+}
+ 
+local ($^W) = 1; #use warnings;
+use strict;
+use Config;
+ 
+BEGIN {
+    if(-d "lib" && -f "TEST") {
+        if ($Config{'extensions'} !~ /\bDB_File\b/ ) {
+            print "1..0 # Skip: DB_File was not built\n";
+            exit 0;
+        }
     }
 }
 
 use DB_File; 
 use Fcntl;
 
-print "1..62\n";
+print "1..143\n";
+
+unlink glob "__db.*";
 
 sub ok
 {
@@ -23,7 +36,63 @@
     print "ok $no\n" ;
 }
 
-$Dfile = "dbhash.tmp";
+{
+    package Redirect ;
+    use Symbol ;
+
+    sub new
+    {
+        my $class = shift ;
+        my $filename = shift ;
+	my $fh = gensym ;
+	open ($fh, ">$filename") || die "Cannot open $filename: $!" ;
+	my $real_stdout = select($fh) ;
+	return bless [$fh, $real_stdout ] ;
+
+    }
+    sub DESTROY
+    {
+        my $self = shift ;
+	close $self->[0] ;
+	select($self->[1]) ;
+    }
+}
+
+sub docat_del
+{ 
+    my $file = shift;
+    local $/ = undef;
+    open(CAT,$file) || die "Cannot open $file: $!";
+    my $result = <CAT>;
+    close(CAT);
+    $result = normalise($result) ;
+    unlink $file ;
+    return $result;
+}   
+
+sub normalise
+{
+    my $data = shift ;
+    $data =~ s#\r\n#\n#g 
+        if $^O eq 'cygwin' ;
+    return $data ;
+}
+
+sub safeUntie
+{
+    my $hashref = shift ;
+    my $no_inner = 1;
+    local $SIG{__WARN__} = sub {-- $no_inner } ;
+    untie %$hashref;
+    return $no_inner;
+}
+
+
+my $Dfile = "dbhash.tmp";
+my $Dfile2 = "dbhash2.tmp";
+my $null_keys_allowed = ($DB_File::db_ver < 2.004010 
+				|| $DB_File::db_ver >= 3.1 );
+
 unlink $Dfile;
 
 umask(0);
@@ -51,8 +120,9 @@
 $dbh->{cachesize} = 65 ;
 ok(10, $dbh->{cachesize} == 65 );
 
-$dbh->{hash} = "abc" ;
-ok(11, $dbh->{hash} eq "abc" );
+my $some_sub = sub {} ;
+$dbh->{hash} = $some_sub;
+ok(11, $dbh->{hash} eq $some_sub );
 
 $dbh->{lorder} = 1234 ;
 ok(12, $dbh->{lorder} == 1234 );
@@ -65,13 +135,19 @@
 
 
 # Now check the interface to HASH
-
+my ($X, %h);
 ok(15, $X = tie(%h, 'DB_File',$Dfile, O_RDWR|O_CREAT, 0640, $DB_HASH ) );
+die "Could not tie: $!" unless $X;
 
-($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
+my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,
    $blksize,$blocks) = stat($Dfile);
-ok(16, ($mode & 0777) == ($^O eq 'os2' ? 0666 : 0640) || $^O eq 'amigaos' || $^O eq 'MSWin32');
 
+my %noMode = map { $_, 1} qw( amigaos MSWin32 NetWare cygwin ) ;
+
+ok(16, ($mode & 0777) == (($^O eq 'os2' || $^O eq 'MacOS') ? 0666 : 0640) ||
+   $noMode{$^O} );
+
+my ($key, $value, $i);
 while (($key,$value) = each(%h)) {
     $i++;
 }
@@ -143,8 +219,8 @@
 delete $h{'goner1'};
 $X->DELETE('goner3');
 
-@keys = keys(%h);
-@values = values(%h);
+my @keys = keys(%h);
+my @values = values(%h);
 
 ok(23, $#keys == 29 && $#values == 29) ;
 
@@ -164,12 +240,19 @@
 $h{'foo'} = '';
 ok(26, $h{'foo'} eq '' );
 
-#$h{''} = 'bar';
-#ok(27, $h{''} eq 'bar' );
-ok(27,1) ;
+# Berkeley DB from version 2.4.10 to 3.0 does not allow null keys.
+# This feature was reenabled in version 3.1 of Berkeley DB.
+my $result = 0 ;
+if ($null_keys_allowed) {
+    $h{''} = 'bar';
+    $result = ( $h{''} eq 'bar' );
+}
+else
+  { $result = 1 }
+ok(27, $result) ;
 
 # check cache overflow and numeric keys and contents
-$ok = 1;
+my $ok = 1;
 for ($i = 1; $i < 200; $i++) { $h{$i + 0} = $i + 0; }
 for ($i = 1; $i < 200; $i++) { $ok = 0 unless $h{$i} == $i; }
 ok(28, $ok );
@@ -179,7 +262,7 @@
 ok(29, $size > 0 );
 
 @h{0..200} = 200..400;
-@foo = @h{0..200};
+my @foo = @h{0..200};
 ok(30, join(':',200..400) eq join(':',@foo) );
 
 
@@ -188,7 +271,7 @@
 # Check NOOVERWRITE will make put fail when attempting to overwrite
 # an existing record.
  
-$status = $X->put( 'x', 'newvalue', R_NOOVERWRITE) ;
+my $status = $X->put( 'x', 'newvalue', R_NOOVERWRITE) ;
 ok(31, $status == 1 );
  
 # check that the value of the key 'x' has not been changed by the 
@@ -211,9 +294,10 @@
 ok(36, $status == 0 );
 
 # Make sure that the key deleted, cannot be retrieved
-$^W = 0 ;
-ok(37, $h{'q'} eq undef );
-$^W = 1 ;
+{
+    local ($^W) = 0; #no warnings 'uninitialized' ;
+    ok(37, $h{'q'} eq undef );
+}
 
 # Attempting to delete a non-existant key should fail
 
@@ -326,6 +410,7 @@
 
    package Another ;
 
+   local ($^W) = 1; #use warnings ;
    use strict ;
 
    open(FILE, ">SubDB.pm") or die "Cannot open SubDB.pm: $!\n" ;
@@ -333,8 +418,9 @@
 
    package SubDB ;
 
+   local ($^W) = 1; #use warnings ;
    use strict ;
-   use vars qw( @ISA @EXPORT) ;
+   use vars qw(@ISA @EXPORT);
 
    require Exporter ;
    use DB_File;
@@ -413,4 +499,492 @@
     unlink "SubDB.pm", "dbhash.tmp" ;
 
 }
+
+{
+   # DBM Filter tests
+   local ($^W) = 1; #use warnings ;
+   use strict ;
+   my (%h, $db) ;
+   my ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   unlink $Dfile;
+
+   sub checkOutput
+   {
+       local ($^W) = 0; #no warnings 'uninitialized';
+       my($fk, $sk, $fv, $sv) = @_ ;
+
+       print "# Fetch Key   : expected '$fk' got '$fetch_key'\n" 
+           if $fetch_key ne $fk ;
+       print "# Fetch Value : expected '$fv' got '$fetch_value'\n" 
+           if $fetch_value ne $fv ;
+       print "# Store Key   : expected '$sk' got '$store_key'\n" 
+           if $store_key ne $sk ;
+       print "# Store Value : expected '$sv' got '$store_value'\n" 
+           if $store_value ne $sv ;
+       print "# \$_          : expected 'original' got '$_'\n" 
+           if $_ ne 'original' ;
+
+       return
+           $fetch_key   eq $fk && $store_key   eq $sk && 
+	   $fetch_value eq $fv && $store_value eq $sv &&
+	   $_ eq 'original' ;
+   }
+   
+   ok(63, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_HASH ) );
+
+   $db->filter_fetch_key   (sub { $fetch_key = $_ }) ;
+   $db->filter_store_key   (sub { $store_key = $_ }) ;
+   $db->filter_fetch_value (sub { $fetch_value = $_}) ;
+   $db->filter_store_value (sub { $store_value = $_ }) ;
+
+   $_ = "original" ;
+
+   $h{"fred"} = "joe" ;
+   #                   fk   sk     fv   sv
+   ok(64, checkOutput( "", "fred", "", "joe")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(65, $h{"fred"} eq "joe");
+   #                   fk    sk     fv    sv
+   ok(66, checkOutput( "", "fred", "joe", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   my ($k, $v) ;
+   $k = 'fred';
+   ok(67, ! $db->seq($k, $v, R_FIRST) ) ;
+   ok(68, $k eq "fred") ;
+   ok(69, $v eq "joe") ;
+   #                    fk     sk  fv  sv
+   ok(70, checkOutput( "fred", "fred", "joe", "")) ;
+
+   # replace the filters, but remember the previous set
+   my ($old_fk) = $db->filter_fetch_key   
+   			(sub { $_ = uc $_ ; $fetch_key = $_ }) ;
+   my ($old_sk) = $db->filter_store_key   
+   			(sub { $_ = lc $_ ; $store_key = $_ }) ;
+   my ($old_fv) = $db->filter_fetch_value 
+   			(sub { $_ = "[$_]"; $fetch_value = $_ }) ;
+   my ($old_sv) = $db->filter_store_value 
+   			(sub { s/o/x/g; $store_value = $_ }) ;
+   
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   $h{"Fred"} = "Joe" ;
+   #                   fk   sk     fv    sv
+   ok(71, checkOutput( "", "fred", "", "Jxe")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(72, $h{"Fred"} eq "[Jxe]");
+   #                   fk   sk     fv    sv
+   ok(73, checkOutput( "", "fred", "[Jxe]", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   $k = 'Fred'; $v ='';
+   ok(74, ! $db->seq($k, $v, R_FIRST) ) ;
+   ok(75, $k eq "FRED") ;
+   ok(76, $v eq "[Jxe]") ;
+   #                   fk   sk     fv    sv
+   ok(77, checkOutput( "FRED", "fred", "[Jxe]", "")) ;
+
+   # put the original filters back
+   $db->filter_fetch_key   ($old_fk);
+   $db->filter_store_key   ($old_sk);
+   $db->filter_fetch_value ($old_fv);
+   $db->filter_store_value ($old_sv);
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   $h{"fred"} = "joe" ;
+   ok(78, checkOutput( "", "fred", "", "joe")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(79, $h{"fred"} eq "joe");
+   ok(80, checkOutput( "", "fred", "joe", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   #ok(77, $db->FIRSTKEY() eq "fred") ;
+   $k = 'fred';
+   ok(81, ! $db->seq($k, $v, R_FIRST) ) ;
+   ok(82, $k eq "fred") ;
+   ok(83, $v eq "joe") ;
+   #                   fk   sk     fv    sv
+   ok(84, checkOutput( "fred", "fred", "joe", "")) ;
+
+   # delete the filters
+   $db->filter_fetch_key   (undef);
+   $db->filter_store_key   (undef);
+   $db->filter_fetch_value (undef);
+   $db->filter_store_value (undef);
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   $h{"fred"} = "joe" ;
+   ok(85, checkOutput( "", "", "", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(86, $h{"fred"} eq "joe");
+   ok(87, checkOutput( "", "", "", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   $k = 'fred';
+   ok(88, ! $db->seq($k, $v, R_FIRST) ) ;
+   ok(89, $k eq "fred") ;
+   ok(90, $v eq "joe") ;
+   ok(91, checkOutput( "", "", "", "")) ;
+
+   undef $db ;
+   untie %h;
+   unlink $Dfile;
+}
+
+{    
+    # DBM Filter with a closure
+
+    local ($^W) = 1; #use warnings ;
+    use strict ;
+    my (%h, $db) ;
+
+    unlink $Dfile;
+    ok(92, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_HASH ) );
+
+    my %result = () ;
+
+    sub Closure
+    {
+        my ($name) = @_ ;
+	my $count = 0 ;
+	my @kept = () ;
+
+	return sub { ++$count ; 
+		     push @kept, $_ ; 
+		     $result{$name} = "$name - $count: [@kept]" ;
+		   }
+    }
+
+    $db->filter_store_key(Closure("store key")) ;
+    $db->filter_store_value(Closure("store value")) ;
+    $db->filter_fetch_key(Closure("fetch key")) ;
+    $db->filter_fetch_value(Closure("fetch value")) ;
+
+    $_ = "original" ;
+
+    $h{"fred"} = "joe" ;
+    ok(93, $result{"store key"} eq "store key - 1: [fred]");
+    ok(94, $result{"store value"} eq "store value - 1: [joe]");
+    ok(95, ! defined $result{"fetch key"} );
+    ok(96, ! defined $result{"fetch value"} );
+    ok(97, $_ eq "original") ;
+
+    ok(98, $db->FIRSTKEY() eq "fred") ;
+    ok(99, $result{"store key"} eq "store key - 1: [fred]");
+    ok(100, $result{"store value"} eq "store value - 1: [joe]");
+    ok(101, $result{"fetch key"} eq "fetch key - 1: [fred]");
+    ok(102, ! defined $result{"fetch value"} );
+    ok(103, $_ eq "original") ;
+
+    $h{"jim"}  = "john" ;
+    ok(104, $result{"store key"} eq "store key - 2: [fred jim]");
+    ok(105, $result{"store value"} eq "store value - 2: [joe john]");
+    ok(106, $result{"fetch key"} eq "fetch key - 1: [fred]");
+    ok(107, ! defined $result{"fetch value"} );
+    ok(108, $_ eq "original") ;
+
+    ok(109, $h{"fred"} eq "joe");
+    ok(110, $result{"store key"} eq "store key - 3: [fred jim fred]");
+    ok(111, $result{"store value"} eq "store value - 2: [joe john]");
+    ok(112, $result{"fetch key"} eq "fetch key - 1: [fred]");
+    ok(113, $result{"fetch value"} eq "fetch value - 1: [joe]");
+    ok(114, $_ eq "original") ;
+
+    undef $db ;
+    untie %h;
+    unlink $Dfile;
+}		
+
+{
+   # DBM Filter recursion detection
+   local ($^W) = 1; #use warnings ;
+   use strict ;
+   my (%h, $db) ;
+   unlink $Dfile;
+
+   ok(115, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_HASH ) );
+
+   $db->filter_store_key (sub { $_ = $h{$_} }) ;
+
+   eval '$h{1} = 1234' ;
+   ok(116, $@ =~ /^recursion detected in filter_store_key at/ );
+   
+   undef $db ;
+   untie %h;
+   unlink $Dfile;
+}
+
+
+{
+   # Examples from the POD
+
+  my $file = "xyzt" ;
+  {
+    my $redirect = new Redirect $file ;
+
+    local ($^W) = 1; #use warnings FATAL => qw(all);
+    use strict ;
+    use DB_File ;
+    use vars qw(%h $k $v);
+
+    unlink "fruit" ;
+    tie %h, "DB_File", "fruit", O_RDWR|O_CREAT, 0640, $DB_HASH 
+        or die "Cannot open file 'fruit': $!\n";
+
+    # Add a few key/value pairs to the file
+    $h{"apple"} = "red" ;
+    $h{"orange"} = "orange" ;
+    $h{"banana"} = "yellow" ;
+    $h{"tomato"} = "red" ;
+
+    # Check for existence of a key
+    print "Banana Exists\n\n" if $h{"banana"} ;
+
+    # Delete a key/value pair.
+    delete $h{"apple"} ;
+
+    # print the contents of the file
+    while (($k, $v) = each %h)
+      { print "$k -> $v\n" }
+
+    untie %h ;
+
+    unlink "fruit" ;
+  }  
+
+  ok(117, docat_del($file) eq <<'EOM') ;
+Banana Exists
+
+orange -> orange
+tomato -> red
+banana -> yellow
+EOM
+   
+}
+
+{
+    # Bug ID 20001013.009
+    #
+    # test that $hash{KEY} = undef doesn't produce the warning
+    #     Use of uninitialized value in null operation 
+    local ($^W) = 1; #use warnings ;
+    use strict ;
+    use DB_File ;
+
+    unlink $Dfile;
+    my %h ;
+    my $a = "";
+    local $SIG{__WARN__} = sub {$a = $_[0]} ;
+    
+    tie %h, 'DB_File', $Dfile or die "Can't open file: $!\n" ;
+    $h{ABC} = undef;
+    ok(118, $a eq "") ;
+    untie %h ;
+    unlink $Dfile;
+}
+
+{
+    # test that %hash = () doesn't produce the warning
+    #     Argument "" isn't numeric in entersub
+    local ($^W) = 1; #use warnings ;
+    use strict ;
+    use DB_File ;
+
+    unlink $Dfile;
+    my %h ;
+    my $a = "";
+    local $SIG{__WARN__} = sub {$a = $_[0]} ;
+    
+    tie %h, 'DB_File', $Dfile or die "Can't open file: $!\n" ;
+    %h = (); ;
+    ok(119, $a eq "") ;
+    untie %h ;
+    unlink $Dfile;
+}
+
+{
+    # When iterating over a tied hash using "each", the key passed to FETCH
+    # will be recycled and passed to NEXTKEY. If a Source Filter modifies the
+    # key in FETCH via a filter_fetch_key method we need to check that the
+    # modified key doesn't get passed to NEXTKEY.
+    # Also Test "keys" & "values" while we are at it.
+
+    local ($^W) = 1; #use warnings ;
+    use strict ;
+    use DB_File ;
+
+    unlink $Dfile;
+    my $bad_key = 0 ;
+    my %h = () ;
+    my $db ;
+    ok(120, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_HASH ) );
+    $db->filter_fetch_key (sub { $_ =~ s/^Beta_/Alpha_/ if defined $_}) ;
+    $db->filter_store_key (sub { $bad_key = 1 if /^Beta_/ ; $_ =~ s/^Alpha_/Beta_/}) ;
+
+    $h{'Alpha_ABC'} = 2 ;
+    $h{'Alpha_DEF'} = 5 ;
+
+    ok(121, $h{'Alpha_ABC'} == 2);
+    ok(122, $h{'Alpha_DEF'} == 5);
+
+    my ($k, $v) = ("","");
+    while (($k, $v) = each %h) {}
+    ok(123, $bad_key == 0);
+
+    $bad_key = 0 ;
+    foreach $k (keys %h) {}
+    ok(124, $bad_key == 0);
+
+    $bad_key = 0 ;
+    foreach $v (values %h) {}
+    ok(125, $bad_key == 0);
+
+    undef $db ;
+    untie %h ;
+    unlink $Dfile;
+}
+
+{
+    # now an error to pass 'hash' a non-code reference
+    my $dbh = new DB_File::HASHINFO ;
+
+    eval { $dbh->{hash} = 2 };
+    ok(126, $@ =~ /^Key 'hash' not associated with a code reference at/);
+
+}
+
+
+#{
+#    # recursion detection in hash
+#    my %hash ;
+#    my $Dfile = "xxx.db";
+#    unlink $Dfile;
+#    my $dbh = new DB_File::HASHINFO ;
+#    $dbh->{hash} = sub { $hash{3} = 4 ; length $_[0] } ;
+# 
+# 
+#    ok(127, tie(%hash, 'DB_File',$Dfile, O_RDWR|O_CREAT, 0640, $dbh ) );
+#
+#    eval {	$hash{1} = 2;
+#    		$hash{4} = 5;
+#	 };
+#
+#    ok(128, $@ =~ /^DB_File hash callback: recursion detected/);
+#    {
+#        no warnings;
+#        untie %hash;
+#    }
+#    unlink $Dfile;
+#}
+
+ok(127,1);
+ok(128,1);
+
+{
+    # Check that two hash's don't interact
+    my %hash1 ;
+    my %hash2 ;
+    my $h1_count = 0;
+    my $h2_count = 0;
+    unlink $Dfile, $Dfile2;
+    my $dbh1 = new DB_File::HASHINFO ;
+    $dbh1->{hash} = sub { ++ $h1_count ; length $_[0] } ;
+
+    my $dbh2 = new DB_File::HASHINFO ;
+    $dbh2->{hash} = sub { ++ $h2_count ; length $_[0] } ;
+ 
+ 
+ 
+    my (%h);
+    ok(129, tie(%hash1, 'DB_File',$Dfile, O_RDWR|O_CREAT, 0640, $dbh1 ) );
+    ok(130, tie(%hash2, 'DB_File',$Dfile2, O_RDWR|O_CREAT, 0640, $dbh2 ) );
+
+    $hash1{DEFG} = 5;
+    $hash1{XYZ} = 2;
+    $hash1{ABCDE} = 5;
+
+    $hash2{defg} = 5;
+    $hash2{xyz} = 2;
+    $hash2{abcde} = 5;
+
+    ok(131, $h1_count > 0);
+    ok(132, $h1_count == $h2_count);
+
+    ok(133, safeUntie \%hash1);
+    ok(134, safeUntie \%hash2);
+    unlink $Dfile, $Dfile2;
+}
+
+{
+    # Passing undef for flags and/or mode when calling tie could cause 
+    #     Use of uninitialized value in subroutine entry
+    
+
+    my $warn_count = 0 ;
+    #local $SIG{__WARN__} = sub { ++ $warn_count };
+    my %hash1;
+    unlink $Dfile;
+
+    tie %hash1, 'DB_File',$Dfile, undef;
+    ok(135, $warn_count == 0);
+    $warn_count = 0;
+    tie %hash1, 'DB_File',$Dfile, O_RDWR|O_CREAT, undef;
+    ok(136, $warn_count == 0);
+    tie %hash1, 'DB_File',$Dfile, undef, undef;
+    ok(137, $warn_count == 0);
+    $warn_count = 0;
+
+    untie %hash1;
+    unlink $Dfile;
+}
+
+{
+   # Check that DBM Filter can cope with read-only $_
+
+   local ($^W) = 1; #use warnings ;
+   use strict ;
+   my (%h, $db) ;
+   my $Dfile = "xxy.db";
+   unlink $Dfile;
+
+   ok(138, $db = tie(%h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_HASH ) );
+
+   $db->filter_fetch_key   (sub { }) ;
+   $db->filter_store_key   (sub { }) ;
+   $db->filter_fetch_value (sub { }) ;
+   $db->filter_store_value (sub { }) ;
+
+   $_ = "original" ;
+
+   $h{"fred"} = "joe" ;
+   ok(139, $h{"fred"} eq "joe");
+
+   eval { grep { $h{$_} } (1, 2, 3) };
+   ok (140, ! $@);
+
+
+   # delete the filters
+   $db->filter_fetch_key   (undef);
+   $db->filter_store_key   (undef);
+   $db->filter_fetch_value (undef);
+   $db->filter_store_value (undef);
+
+   $h{"fred"} = "joe" ;
+
+   ok(141, $h{"fred"} eq "joe");
+
+   ok(142, $db->FIRSTKEY() eq "fred") ;
+   
+   eval { grep { $h{$_} } (1, 2, 3) };
+   ok (143, ! $@);
+
+   undef $db ;
+   untie %h;
+   unlink $Dfile;
+}
+
+
 exit ;
diff -ru perl5.005.orig/t/lib/db-recno.t perl5.005/t/lib/db-recno.t
--- perl5.005.orig/t/lib/db-recno.t	2008-09-19 02:43:48.000000000 +0100
+++ perl5.005/t/lib/db-recno.t	2008-09-19 03:18:10.000000000 +0100
@@ -1,18 +1,31 @@
 #!./perl -w
 
+print "1..0 # SKIP Unknown\n";
+exit 0;
+
+BEGIN {
+    unless(grep /blib/, @INC) {
+        chdir 't' if -d 't';
+        @INC = '../lib' if -d '../lib';
+    }
+}
+ 
+local ($^W) = 1; #use warnings;
+use strict;
+use Config;
+ 
 BEGIN {
-    @INC = '../lib' if -d '../lib' ;
-    require Config; import Config;
-    if ($Config{'extensions'} !~ /\bDB_File\b/) {
-	print "1..0\n";
-	exit 0;
+    if(-d "lib" && -f "TEST") {
+        if ($Config{'extensions'} !~ /\bDB_File\b/ ) {
+            print "1..0 # Skip: DB_File was not built\n";
+            exit 0;
+        }
     }
 }
 
 use DB_File; 
 use Fcntl;
-use strict ;
-use vars qw($dbh $Dfile $bad_ones $FA) ;
+use vars qw($dbh $Dfile $bad_ones $FA);
 
 # full tied array support started in Perl 5.004_57
 # Double check to see if it is available.
@@ -38,32 +51,118 @@
     return $result ;
 }
 
+{
+    package Redirect ;
+    use Symbol ;
+
+    sub new
+    {
+        my $class = shift ;
+        my $filename = shift ;
+	my $fh = gensym ;
+	open ($fh, ">$filename") || die "Cannot open $filename: $!" ;
+	my $real_stdout = select($fh) ;
+	return bless [$fh, $real_stdout ] ;
+
+    }
+    sub DESTROY
+    {
+        my $self = shift ;
+	close $self->[0] ;
+	select($self->[1]) ;
+    }
+}
+
+sub docat
+{
+    my $file = shift;
+    local $/ = undef;
+    open(CAT,$file) || die "Cannot open $file:$!";
+    my $result = <CAT>;
+    close(CAT);
+    normalise($result) ;
+    return $result;
+}
+
+sub docat_del
+{ 
+    my $file = shift;
+    my $result = docat($file);
+    unlink $file ;
+    return $result;
+}   
+
+sub safeUntie
+{
+    my $hashref = shift ;
+    my $no_inner = 1;
+    local $SIG{__WARN__} = sub {-- $no_inner } ;
+    untie @$hashref;
+    return $no_inner;
+}
+
 sub bad_one
 {
-    print STDERR <<EOM unless $bad_ones++ ;
+    unless ($bad_ones++) {
+	print STDERR <<EOM ;
 #
-# Some older versions of Berkeley DB will fail tests 51, 53 and 55.
+# Some older versions of Berkeley DB version 1 will fail db-recno
+# tests 61, 63, 64 and 65.
+EOM
+        if ($^O eq 'darwin' && ($DB_File::db_version || 0) < 2) {
+	    print STDERR <<EOM ;
+#
+# For example Mac OS X 10.2 (or earlier) has such an old
+# version of Berkeley DB.
+EOM
+	}
+
+	print STDERR <<EOM ;
 #
 # You can safely ignore the errors if you're never going to use the
 # broken functionality (recno databases with a modified bval). 
 # Otherwise you'll have to upgrade your DB library.
 #
-# If you want to upgrade Berkeley DB, the most recent version is 1.85.
-# Check out http://www.bostic.com/db for more details.
+# If you want to use Berkeley DB version 1, then 1.85 and 1.86 are the
+# last versions that were released. Berkeley DB version 2 is continually
+# being updated -- Check out http://www.sleepycat.com/ for more details.
 #
 EOM
+    }
 }
 
-print "1..78\n";
+sub normalise
+{
+    return unless $^O eq 'cygwin' ;
+    foreach (@_)
+      { s#\r\n#\n#g }     
+}
+
+BEGIN 
+{ 
+    { 
+        local $SIG{__DIE__} ; 
+        eval { require Data::Dumper ; import Data::Dumper } ; 
+    }
+ 
+    if ($@) {
+        *Dumper = sub { my $a = shift; return "[ @{ $a } ]" } ;
+    }          
+}
+
+my $splice_tests = 10 + 12 + 1; # ten regressions, plus the randoms
+my $total_tests = 158 ;
+$total_tests += $splice_tests if $FA ;
+print "1..$total_tests\n";   
 
-my $Dfile = "recno.tmp";
+$Dfile = "recno.tmp";
 unlink $Dfile ;
 
 umask(0);
 
 # Check the interface to RECNOINFO
 
-my $dbh = new DB_File::RECNOINFO ;
+$dbh = new DB_File::RECNOINFO ;
 ok(1, ! defined $dbh->{bval}) ;
 ok(2, ! defined $dbh->{cachesize}) ;
 ok(3, ! defined $dbh->{psize}) ;
@@ -106,8 +205,10 @@
 my @h ;
 ok(17, $X = tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_RECNO ) ;
 
-ok(18, ((stat($Dfile))[2] & 0777) == ($^O eq 'os2' ? 0666 : 0640)
-	||  $^O eq 'MSWin32' || $^O eq 'amigaos') ;
+my %noMode = map { $_, 1} qw( amigaos MSWin32 NetWare cygwin ) ;
+
+ok(18, ((stat($Dfile))[2] & 0777) == (($^O eq 'os2' || $^O eq 'MacOS') ? 0666 : 0640)
+	||  $noMode{$^O} );
 
 #my $l = @h ;
 my $l = $X->length ;
@@ -156,7 +257,7 @@
 # UNSHIFT
 
 # empty list
-($FA ? unshift @h : $X->unshift) ;
+($FA ? unshift @h,() : $X->unshift) ;
 ok(31, ($FA ? @h == @data : $X->length == @data ));
 
 my @new_data = qw(add this to the start of the array) ;
@@ -173,7 +274,25 @@
 ok(40, $h[7] eq "array") ;
 ok(41, $h[8] eq $data[8]) ;
 
-# SPLICE
+# Brief test for SPLICE - more thorough 'soak test' is later.
+my @old;
+if ($FA) {
+    @old = splice(@h, 1, 2, qw(bananas just before));
+}
+else {
+    @old = $X->splice(1, 2, qw(bananas just before));
+}
+ok(42, $h[0] eq "add") ;
+ok(43, $h[1] eq "bananas") ;
+ok(44, $h[2] eq "just") ;
+ok(45, $h[3] eq "before") ;
+ok(46, $h[4] eq "the") ;
+ok(47, $h[5] eq "start") ;
+ok(48, $h[6] eq "of") ;
+ok(49, $h[7] eq "the") ;
+ok(50, $h[8] eq "array") ;
+ok(51, $h[9] eq $data[8]) ;
+$FA ? splice(@h, 1, 3, @old) : $X->splice(1, 3, @old);
 
 # Now both arrays should be identical
 
@@ -183,54 +302,44 @@
 {
    $ok = 0, last if $_ ne $h[$j ++] ; 
 }
-ok(42, $ok );
+ok(52, $ok );
 
 # Neagtive subscripts
 
 # get the last element of the array
-ok(43, $h[-1] eq $data[-1] );
-ok(44, $h[-1] eq $h[ ($FA ? @h : $X->length) -1] );
+ok(53, $h[-1] eq $data[-1] );
+ok(54, $h[-1] eq $h[ ($FA ? @h : $X->length) -1] );
 
 # get the first element using a negative subscript
 eval '$h[ - ( $FA ? @h : $X->length)] = "abcd"' ;
-ok(45, $@ eq "" );
-ok(46, $h[0] eq "abcd" );
+ok(55, $@ eq "" );
+ok(56, $h[0] eq "abcd" );
 
 # now try to read before the start of the array
 eval '$h[ - (1 + ($FA ? @h : $X->length))] = 1234' ;
-ok(47, $@ =~ '^Modification of non-creatable array value attempted' );
+ok(57, $@ =~ '^Modification of non-creatable array value attempted' );
 
 # IMPORTANT - $X must be undefined before the untie otherwise the
 #             underlying DB close routine will not get called.
 undef $X ;
-untie(@h);
+ok(58, safeUntie \@h);
 
 unlink $Dfile;
 
-sub docat
-{
-    my $file = shift;
-    local $/ = undef;
-    open(CAT,$file) || die "Cannot open $file:$!";
-    my $result = <CAT>;
-    close(CAT);
-    return $result;
-}
-
 
 {
     # Check bval defaults to \n
 
     my @h = () ;
     my $dbh = new DB_File::RECNOINFO ;
-    ok(48, tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $dbh ) ;
+    ok(59, tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $dbh ) ;
     $h[0] = "abc" ;
     $h[1] = "def" ;
     $h[3] = "ghi" ;
-    untie @h ;
+    ok(60, safeUntie \@h);
     my $x = docat($Dfile) ;
     unlink $Dfile;
-    ok(49, $x eq "abc\ndef\n\nghi\n") ;
+    ok(61, $x eq "abc\ndef\n\nghi\n") ;
 }
 
 {
@@ -239,16 +348,16 @@
     my @h = () ;
     my $dbh = new DB_File::RECNOINFO ;
     $dbh->{bval} = "-" ;
-    ok(50, tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $dbh ) ;
+    ok(62, tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $dbh ) ;
     $h[0] = "abc" ;
     $h[1] = "def" ;
     $h[3] = "ghi" ;
-    untie @h ;
+    ok(63, safeUntie \@h);
     my $x = docat($Dfile) ;
     unlink $Dfile;
     my $ok = ($x eq "abc-def--ghi-") ;
     bad_one() unless $ok ;
-    ok(51, $ok) ;
+    ok(64, $ok) ;
 }
 
 {
@@ -258,16 +367,16 @@
     my $dbh = new DB_File::RECNOINFO ;
     $dbh->{flags} = R_FIXEDLEN ;
     $dbh->{reclen} = 5 ;
-    ok(52, tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $dbh ) ;
+    ok(65, tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $dbh ) ;
     $h[0] = "abc" ;
     $h[1] = "def" ;
     $h[3] = "ghi" ;
-    untie @h ;
+    ok(66, safeUntie \@h);
     my $x = docat($Dfile) ;
     unlink $Dfile;
     my $ok = ($x eq "abc  def       ghi  ") ;
     bad_one() unless $ok ;
-    ok(53, $ok) ;
+    ok(67, $ok) ;
 }
 
 {
@@ -278,16 +387,16 @@
     $dbh->{flags} = R_FIXEDLEN ;
     $dbh->{bval} = "-" ;
     $dbh->{reclen} = 5 ;
-    ok(54, tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $dbh ) ;
+    ok(68, tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $dbh ) ;
     $h[0] = "abc" ;
     $h[1] = "def" ;
     $h[3] = "ghi" ;
-    untie @h ;
+    ok(69, safeUntie \@h);
     my $x = docat($Dfile) ;
     unlink $Dfile;
     my $ok = ($x eq "abc--def-------ghi--") ;
     bad_one() unless $ok ;
-    ok(55, $ok) ;
+    ok(70, $ok) ;
 }
 
 {
@@ -296,7 +405,7 @@
     my $filename = "xyz" ;
     my %x ;
     eval { tie %x, 'DB_File', $filename, O_RDWR|O_CREAT, 0640, $DB_RECNO ; } ;
-    ok(56, $@ =~ /^DB_File can only tie an array to a DB_RECNO database/) ;
+    ok(71, $@ =~ /^DB_File can only tie an array to a DB_RECNO database/) ;
     unlink $filename ;
 }
 
@@ -305,6 +414,7 @@
 
    package Another ;
 
+   local ($^W) = 1; #use warnings ;
    use strict ;
 
    open(FILE, ">SubDB.pm") or die "Cannot open SubDB.pm: $!\n" ;
@@ -312,8 +422,9 @@
 
    package SubDB ;
 
+   local ($^W) = 1; #use warnings ;
    use strict ;
-   use vars qw( @ISA @EXPORT) ;
+   use vars qw(@ISA @EXPORT);
 
    require Exporter ;
    use DB_File;
@@ -357,38 +468,39 @@
    1 ;
 EOM
 
-    close FILE ;
+    close FILE  or die "Could not close: $!";
 
     BEGIN { push @INC, '.'; } 
     eval 'use SubDB ; ';
-    main::ok(57, $@ eq "") ;
+    main::ok(72, $@ eq "") ;
     my @h ;
     my $X ;
     eval '
 	$X = tie(@h, "SubDB","recno.tmp", O_RDWR|O_CREAT, 0640, $DB_RECNO );
 	' ;
+    die "Could not tie: $!" unless $X;
 
-    main::ok(58, $@ eq "") ;
+    main::ok(73, $@ eq "") ;
 
     my $ret = eval '$h[3] = 3 ; return $h[3] ' ;
-    main::ok(59, $@ eq "") ;
-    main::ok(60, $ret == 5) ;
+    main::ok(74, $@ eq "") ;
+    main::ok(75, $ret == 5) ;
 
     my $value = 0;
     $ret = eval '$X->put(1, 4) ; $X->get(1, $value) ; return $value' ;
-    main::ok(61, $@ eq "") ;
-    main::ok(62, $ret == 10) ;
+    main::ok(76, $@ eq "") ;
+    main::ok(77, $ret == 10) ;
 
     $ret = eval ' R_NEXT eq main::R_NEXT ' ;
-    main::ok(63, $@ eq "" ) ;
-    main::ok(64, $ret == 1) ;
+    main::ok(78, $@ eq "" ) ;
+    main::ok(79, $ret == 1) ;
 
     $ret = eval '$X->A_new_method(1) ' ;
-    main::ok(65, $@ eq "") ;
-    main::ok(66, $ret eq "[[11]]") ;
+    main::ok(80, $@ eq "") ;
+    main::ok(81, $ret eq "[[11]]") ;
 
     undef $X;
-    untie(@h);
+    main::ok(82, main::safeUntie \@h);
     unlink "SubDB.pm", "recno.tmp" ;
 
 }
@@ -398,56 +510,921 @@
     # test $#
     my $self ;
     unlink $Dfile;
-    ok(67, $self = tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_RECNO ) ;
+    ok(83, $self = tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_RECNO ) ;
     $h[0] = "abc" ;
     $h[1] = "def" ;
     $h[2] = "ghi" ;
     $h[3] = "jkl" ;
-    ok(68, $FA ? $#h == 3 : $self->length() == 4) ;
+    ok(84, $FA ? $#h == 3 : $self->length() == 4) ;
     undef $self ;
-    untie @h ;
+    ok(85, safeUntie \@h);
     my $x = docat($Dfile) ;
-    ok(69, $x eq "abc\ndef\nghi\njkl\n") ;
+    ok(86, $x eq "abc\ndef\nghi\njkl\n") ;
 
     # $# sets array to same length
-    ok(70, $self = tie @h, 'DB_File', $Dfile, O_RDWR, 0640, $DB_RECNO ) ;
+    ok(87, $self = tie @h, 'DB_File', $Dfile, O_RDWR, 0640, $DB_RECNO ) ;
     if ($FA)
       { $#h = 3 }
     else 
       { $self->STORESIZE(4) }
-    ok(71, $FA ? $#h == 3 : $self->length() == 4) ;
+    ok(88, $FA ? $#h == 3 : $self->length() == 4) ;
     undef $self ;
-    untie @h ;
+    ok(89, safeUntie \@h);
     $x = docat($Dfile) ;
-    ok(72, $x eq "abc\ndef\nghi\njkl\n") ;
+    ok(90, $x eq "abc\ndef\nghi\njkl\n") ;
 
     # $# sets array to bigger
-    ok(73, $self = tie @h, 'DB_File', $Dfile, O_RDWR, 0640, $DB_RECNO ) ;
+    ok(91, $self = tie @h, 'DB_File', $Dfile, O_RDWR, 0640, $DB_RECNO ) ;
     if ($FA)
       { $#h = 6 }
     else 
       { $self->STORESIZE(7) }
-    ok(74, $FA ? $#h == 6 : $self->length() == 7) ;
+    ok(92, $FA ? $#h == 6 : $self->length() == 7) ;
     undef $self ;
-    untie @h ;
+    ok(93, safeUntie \@h);
     $x = docat($Dfile) ;
-    ok(75, $x eq "abc\ndef\nghi\njkl\n\n\n\n") ;
+    ok(94, $x eq "abc\ndef\nghi\njkl\n\n\n\n") ;
 
     # $# sets array smaller
-    ok(76, $self = tie @h, 'DB_File', $Dfile, O_RDWR, 0640, $DB_RECNO ) ;
+    ok(95, $self = tie @h, 'DB_File', $Dfile, O_RDWR, 0640, $DB_RECNO ) ;
     if ($FA)
       { $#h = 2 }
     else 
       { $self->STORESIZE(3) }
-    ok(77, $FA ? $#h == 2 : $self->length() == 3) ;
+    ok(96, $FA ? $#h == 2 : $self->length() == 3) ;
     undef $self ;
-    untie @h ;
+    ok(97, safeUntie \@h);
     $x = docat($Dfile) ;
-    ok(78, $x eq "abc\ndef\nghi\n") ;
+    ok(98, $x eq "abc\ndef\nghi\n") ;
 
     unlink $Dfile;
 
 
 }
 
+{
+   # DBM Filter tests
+   local ($^W) = 1; #use warnings ;
+   use strict ;
+   my (@h, $db) ;
+   my ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   unlink $Dfile;
+
+   sub checkOutput
+   {
+       my($fk, $sk, $fv, $sv) = @_ ;
+
+       print "# Fetch Key   : expected '$fk' got '$fetch_key'\n" 
+           if $fetch_key ne $fk ;
+       print "# Fetch Value : expected '$fv' got '$fetch_value'\n" 
+           if $fetch_value ne $fv ;
+       print "# Store Key   : expected '$sk' got '$store_key'\n" 
+           if $store_key ne $sk ;
+       print "# Store Value : expected '$sv' got '$store_value'\n" 
+           if $store_value ne $sv ;
+       print "# \$_          : expected 'original' got '$_'\n" 
+           if $_ ne 'original' ;
+
+       return
+           $fetch_key   eq $fk && $store_key   eq $sk && 
+	   $fetch_value eq $fv && $store_value eq $sv &&
+	   $_ eq 'original' ;
+   }
+   
+   ok(99, $db = tie(@h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_RECNO ) );
+
+   $db->filter_fetch_key   (sub { $fetch_key = $_ }) ;
+   $db->filter_store_key   (sub { $store_key = $_ }) ;
+   $db->filter_fetch_value (sub { $fetch_value = $_}) ;
+   $db->filter_store_value (sub { $store_value = $_ }) ;
+
+   $_ = "original" ;
+
+   $h[0] = "joe" ;
+   #                   fk   sk     fv   sv
+   ok(100, checkOutput( "", 0, "", "joe")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(101, $h[0] eq "joe");
+   #                   fk  sk  fv    sv
+   ok(102, checkOutput( "", 0, "joe", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(103, $db->FIRSTKEY() == 0) ;
+   #                    fk     sk  fv  sv
+   ok(104, checkOutput( 0, "", "", "")) ;
+
+   # replace the filters, but remember the previous set
+   my ($old_fk) = $db->filter_fetch_key   
+   			(sub { ++ $_ ; $fetch_key = $_ }) ;
+   my ($old_sk) = $db->filter_store_key   
+   			(sub { $_ *= 2 ; $store_key = $_ }) ;
+   my ($old_fv) = $db->filter_fetch_value 
+   			(sub { $_ = "[$_]"; $fetch_value = $_ }) ;
+   my ($old_sv) = $db->filter_store_value 
+   			(sub { s/o/x/g; $store_value = $_ }) ;
+   
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   $h[1] = "Joe" ;
+   #                   fk   sk     fv    sv
+   ok(105, checkOutput( "", 2, "", "Jxe")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(106, $h[1] eq "[Jxe]");
+   #                   fk   sk     fv    sv
+   ok(107, checkOutput( "", 2, "[Jxe]", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(108, $db->FIRSTKEY() == 1) ;
+   #                   fk   sk     fv    sv
+   ok(109, checkOutput( 1, "", "", "")) ;
+   
+   # put the original filters back
+   $db->filter_fetch_key   ($old_fk);
+   $db->filter_store_key   ($old_sk);
+   $db->filter_fetch_value ($old_fv);
+   $db->filter_store_value ($old_sv);
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   $h[0] = "joe" ;
+   ok(110, checkOutput( "", 0, "", "joe")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(111, $h[0] eq "joe");
+   ok(112, checkOutput( "", 0, "joe", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(113, $db->FIRSTKEY() == 0) ;
+   ok(114, checkOutput( 0, "", "", "")) ;
+
+   # delete the filters
+   $db->filter_fetch_key   (undef);
+   $db->filter_store_key   (undef);
+   $db->filter_fetch_value (undef);
+   $db->filter_store_value (undef);
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   $h[0] = "joe" ;
+   ok(115, checkOutput( "", "", "", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(116, $h[0] eq "joe");
+   ok(117, checkOutput( "", "", "", "")) ;
+
+   ($fetch_key, $store_key, $fetch_value, $store_value) = ("") x 4 ;
+   ok(118, $db->FIRSTKEY() == 0) ;
+   ok(119, checkOutput( "", "", "", "")) ;
+
+   undef $db ;
+   ok(120, safeUntie \@h);
+   unlink $Dfile;
+}
+
+{    
+    # DBM Filter with a closure
+
+    local ($^W) = 1; #use warnings ;
+    use strict ;
+    my (@h, $db) ;
+
+    unlink $Dfile;
+    ok(121, $db = tie(@h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_RECNO ) );
+
+    my %result = () ;
+
+    sub Closure
+    {
+        my ($name) = @_ ;
+	my $count = 0 ;
+	my @kept = () ;
+
+	return sub { ++$count ; 
+		     push @kept, $_ ; 
+		     $result{$name} = "$name - $count: [@kept]" ;
+		   }
+    }
+
+    $db->filter_store_key(Closure("store key")) ;
+    $db->filter_store_value(Closure("store value")) ;
+    $db->filter_fetch_key(Closure("fetch key")) ;
+    $db->filter_fetch_value(Closure("fetch value")) ;
+
+    $_ = "original" ;
+
+    $h[0] = "joe" ;
+    ok(122, $result{"store key"} eq "store key - 1: [0]");
+    ok(123, $result{"store value"} eq "store value - 1: [joe]");
+    ok(124, ! defined $result{"fetch key"} );
+    ok(125, ! defined $result{"fetch value"} );
+    ok(126, $_ eq "original") ;
+
+    ok(127, $db->FIRSTKEY() == 0 ) ;
+    ok(128, $result{"store key"} eq "store key - 1: [0]");
+    ok(129, $result{"store value"} eq "store value - 1: [joe]");
+    ok(130, $result{"fetch key"} eq "fetch key - 1: [0]");
+    ok(131, ! defined $result{"fetch value"} );
+    ok(132, $_ eq "original") ;
+
+    $h[7]  = "john" ;
+    ok(133, $result{"store key"} eq "store key - 2: [0 7]");
+    ok(134, $result{"store value"} eq "store value - 2: [joe john]");
+    ok(135, $result{"fetch key"} eq "fetch key - 1: [0]");
+    ok(136, ! defined $result{"fetch value"} );
+    ok(137, $_ eq "original") ;
+
+    ok(138, $h[0] eq "joe");
+    ok(139, $result{"store key"} eq "store key - 3: [0 7 0]");
+    ok(140, $result{"store value"} eq "store value - 2: [joe john]");
+    ok(141, $result{"fetch key"} eq "fetch key - 1: [0]");
+    ok(142, $result{"fetch value"} eq "fetch value - 1: [joe]");
+    ok(143, $_ eq "original") ;
+
+    undef $db ;
+    ok(144, safeUntie \@h);
+    unlink $Dfile;
+}		
+
+{
+   # DBM Filter recursion detection
+   local ($^W) = 1; #use warnings ;
+   use strict ;
+   my (@h, $db) ;
+   unlink $Dfile;
+
+   ok(145, $db = tie(@h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_RECNO ) );
+
+   $db->filter_store_key (sub { $_ = $h[0] }) ;
+
+   eval '$h[1] = 1234' ;
+   ok(146, $@ =~ /^recursion detected in filter_store_key at/ );
+   
+   undef $db ;
+   ok(147, safeUntie \@h);
+   unlink $Dfile;
+}
+
+
+{
+   # Examples from the POD
+
+  my $file = "xyzt" ;
+  {
+    my $redirect = new Redirect $file ;
+
+    local ($^W) = 1; #use warnings FATAL => qw(all);
+    use strict ;
+    use DB_File ;
+
+    my $filename = "text" ;
+    unlink $filename ;
+
+    my @h ;
+    my $x = tie @h, "DB_File", $filename, O_RDWR|O_CREAT, 0640, $DB_RECNO 
+        or die "Cannot open file 'text': $!\n" ;
+
+    # Add a few key/value pairs to the file
+    $h[0] = "orange" ;
+    $h[1] = "blue" ;
+    $h[2] = "yellow" ;
+
+    $FA ? push @h, "green", "black" 
+        : $x->push("green", "black") ;
+
+    my $elements = $FA ? scalar @h : $x->length ;
+    print "The array contains $elements entries\n" ;
+
+    my $last = $FA ? pop @h : $x->pop ;
+    print "popped $last\n" ;
+
+    $FA ? unshift @h, "white" 
+        : $x->unshift("white") ;
+    my $first = $FA ? shift @h : $x->shift ;
+    print "shifted $first\n" ;
+
+    # Check for existence of a key
+    print "Element 1 Exists with value $h[1]\n" if $h[1] ;
+
+    # use a negative index
+    print "The last element is $h[-1]\n" ;
+    print "The 2nd last element is $h[-2]\n" ;
+
+    undef $x ;
+    untie @h ;
+
+    unlink $filename ;
+  }  
+
+  ok(148, docat_del($file) eq <<'EOM') ;
+The array contains 5 entries
+popped black
+shifted white
+Element 1 Exists with value blue
+The last element is green
+The 2nd last element is yellow
+EOM
+
+  my $save_output = "xyzt" ;
+  {
+    my $redirect = new Redirect $save_output ;
+
+    local ($^W) = 1; #use warnings FATAL => qw(all);
+    use strict ;
+    use vars qw(@h $H $file $i);
+    use DB_File ;
+    use Fcntl ;
+    
+    $file = "text" ;
+
+    unlink $file ;
+
+    $H = tie @h, "DB_File", $file, O_RDWR|O_CREAT, 0640, $DB_RECNO 
+        or die "Cannot open file $file: $!\n" ;
+    
+    # first create a text file to play with
+    $h[0] = "zero" ;
+    $h[1] = "one" ;
+    $h[2] = "two" ;
+    $h[3] = "three" ;
+    $h[4] = "four" ;
+
+    
+    # Print the records in order.
+    #
+    # The length method is needed here because evaluating a tied
+    # array in a scalar context does not return the number of
+    # elements in the array.  
+
+    print "\nORIGINAL\n" ;
+    foreach $i (0 .. $H->length - 1) {
+        print "$i: $h[$i]\n" ;
+    }
+
+    # use the push & pop methods
+    $a = $H->pop ;
+    $H->push("last") ;
+    print "\nThe last record was [$a]\n" ;
+
+    # and the shift & unshift methods
+    $a = $H->shift ;
+    $H->unshift("first") ;
+    print "The first record was [$a]\n" ;
+
+    # Use the API to add a new record after record 2.
+    $i = 2 ;
+    $H->put($i, "Newbie", R_IAFTER) ;
+
+    # and a new record before record 1.
+    $i = 1 ;
+    $H->put($i, "New One", R_IBEFORE) ;
+
+    # delete record 3
+    $H->del(3) ;
+
+    # now print the records in reverse order
+    print "\nREVERSE\n" ;
+    for ($i = $H->length - 1 ; $i >= 0 ; -- $i)
+      { print "$i: $h[$i]\n" }
+
+    # same again, but use the API functions instead
+    print "\nREVERSE again\n" ;
+    my ($s, $k, $v)  = (0, 0, 0) ;
+    for ($s = $H->seq($k, $v, R_LAST) ; 
+             $s == 0 ; 
+             $s = $H->seq($k, $v, R_PREV))
+      { print "$k: $v\n" }
+
+    undef $H ;
+    untie @h ;    
+
+    unlink $file ;
+  }  
+
+  ok(149, docat_del($save_output) eq <<'EOM') ;
+
+ORIGINAL
+0: zero
+1: one
+2: two
+3: three
+4: four
+
+The last record was [four]
+The first record was [zero]
+
+REVERSE
+5: last
+4: three
+3: Newbie
+2: one
+1: New One
+0: first
+
+REVERSE again
+5: last
+4: three
+3: Newbie
+2: one
+1: New One
+0: first
+EOM
+   
+}
+
+{
+    # Bug ID 20001013.009
+    #
+    # test that $hash{KEY} = undef doesn't produce the warning
+    #     Use of uninitialized value in null operation 
+    local ($^W) = 1; #use warnings ;
+    use strict ;
+    use DB_File ;
+
+    unlink $Dfile;
+    my @h ;
+    my $a = "";
+    local $SIG{__WARN__} = sub {$a = $_[0]} ;
+    
+    tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0664, $DB_RECNO 
+	or die "Can't open file: $!\n" ;
+    $h[0] = undef;
+    ok(150, $a eq "") ;
+    ok(151, safeUntie \@h);
+    unlink $Dfile;
+}
+
+{
+    # test that %hash = () doesn't produce the warning
+    #     Argument "" isn't numeric in entersub
+    local ($^W) = 1; #use warnings ;
+    use strict ;
+    use DB_File ;
+    my $a = "";
+    local $SIG{__WARN__} = sub {$a = $_[0]} ;
+
+    unlink $Dfile;
+    my @h ;
+    
+    tie @h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0664, $DB_RECNO 
+	or die "Can't open file: $!\n" ;
+    @h = (); ;
+    ok(152, $a eq "") ;
+    ok(153, safeUntie \@h);
+    unlink $Dfile;
+}
+
+{
+   # Check that DBM Filter can cope with read-only $_
+
+   local ($^W) = 1; #use warnings ;
+   use strict ;
+   my (@h, $db) ;
+   unlink $Dfile;
+
+   ok(154, $db = tie(@h, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0640, $DB_RECNO ) );
+
+   $db->filter_fetch_key   (sub { }) ;
+   $db->filter_store_key   (sub { }) ;
+   $db->filter_fetch_value (sub { }) ;
+   $db->filter_store_value (sub { }) ;
+
+   $_ = "original" ;
+
+   $h[0] = "joe" ;
+   ok(155, $h[0] eq "joe");
+
+   eval { grep { $h[$_] } (1, 2, 3) };
+   ok (156, ! $@);
+
+
+   # delete the filters
+   $db->filter_fetch_key   (undef);
+   $db->filter_store_key   (undef);
+   $db->filter_fetch_value (undef);
+   $db->filter_store_value (undef);
+
+   $h[1] = "joe" ;
+
+   ok(157, $h[1] eq "joe");
+
+   eval { grep { $h[$_] } (1, 2, 3) };
+   ok (158, ! $@);
+
+   undef $db ;
+   untie @h;
+   unlink $Dfile;
+}
+
+# Only test splice if this is a newish version of Perl
+exit unless $FA ;
+
+# Test SPLICE
+
+{
+    # check that the splice warnings are under the same lexical control
+    # as their non-tied counterparts.
+
+    local ($^W) = 1; #use warnings;
+    use strict;
+
+    my $a = '';
+    my @a = (1);
+    local $SIG{__WARN__} = sub {$a = $_[0]} ;
+
+    unlink $Dfile;
+    my @tied ;
+    
+    tie @tied, 'DB_File', $Dfile, O_RDWR|O_CREAT, 0664, $DB_RECNO 
+	or die "Can't open file: $!\n" ;
+
+    # uninitialized offset
+    local ($^W) = 1; #use warnings;
+    my $offset ;
+    $a = '';
+    splice(@a, $offset);
+    ok(159, $a =~ /^Use of uninitialized value /);
+    $a = '';
+    splice(@tied, $offset);
+    ok(160, $a =~ /^Use of uninitialized value in splice/);
+
+    local ($^W) = 0; #no warnings 'uninitialized';
+    $a = '';
+    splice(@a, $offset);
+    ok(161, $a eq '');
+    $a = '';
+    splice(@tied, $offset);
+    ok(162, $a eq '');
+
+    # uninitialized length
+    local ($^W) = 1; #use warnings;
+    my $length ;
+    $a = '';
+    splice(@a, 0, $length);
+    ok(163, $a =~ /^Use of uninitialized value /);
+    $a = '';
+    splice(@tied, 0, $length);
+    ok(164, $a =~ /^Use of uninitialized value in splice/);
+
+    local ($^W) = 0; #no warnings 'uninitialized';
+    $a = '';
+    splice(@a, 0, $length);
+    ok(165, $a eq '');
+    $a = '';
+    splice(@tied, 0, $length);
+    ok(166, $a eq '');
+
+    # offset past end of array
+    local ($^W) = 1; #use warnings;
+    $a = '';
+    splice(@a, 3);
+    my $splice_end_array = ($a =~ /^splice\(\) offset past end of array/);
+    $a = '';
+    splice(@tied, 3);
+    ok(167, !$splice_end_array || $a =~ /^splice\(\) offset past end of array/);
+
+    local ($^W) = 0; #no warnings 'misc';
+    $a = '';
+    splice(@a, 3);
+    ok(168, $a eq '');
+    $a = '';
+    splice(@tied, 3);
+    ok(169, $a eq '');
+
+    ok(170, safeUntie \@tied);
+    unlink $Dfile;
+}
+
+# 
+# These are a few regression tests: bundles of five arguments to pass
+# to test_splice().  The first four arguments correspond to those
+# given to splice(), and the last says which context to call it in
+# (scalar, list or void).
+# 
+# The expected result is not needed because we get that by running
+# Perl's built-in splice().
+# 
+my @tests = ([ [ 'falsely', 'dinosaur', 'remedy', 'commotion',
+		 'rarely', 'paleness' ],
+	       -4, -2,
+	       [ 'redoubled', 'Taylorize', 'Zoe', 'halogen' ],
+	       'void' ],
+
+	     [ [ 'a' ], -2, 1, [ 'B' ], 'void' ],
+
+	     [ [ 'Hartley', 'Islandia', 'assents', 'wishful' ],
+	       0, -4,
+	       [ 'maids' ],
+	       'void' ],
+
+	     [ [ 'visibility', 'pocketful', 'rectangles' ],
+	       -10, 0,
+	       [ 'garbages' ],
+	       'void' ],
+
+	     [ [ 'sleeplessly' ],
+	       8, -4,
+	       [ 'Margery', 'clearing', 'repercussion', 'clubs',
+		 'arise' ],
+	       'void' ],
+
+	     [ [ 'chastises', 'recalculates' ],
+	       0, 0,
+	       [ 'momentariness', 'mediates', 'accents', 'toils',
+		 'regaled' ],
+	       'void' ],
+
+	     [ [ 'b', '' ],
+	       9, 8,
+	       [ 'otrb', 'stje', 'ixrpw', 'vxfx', 'lhhf' ],
+	       'scalar' ],
+
+	     [ [ 'b', '' ],
+	       undef, undef,
+	       [ 'otrb', 'stje', 'ixrpw', 'vxfx', 'lhhf' ],
+	       'scalar' ],
+	     
+	     [ [ 'riheb' ], -8, undef, [], 'void' ],
+
+	     [ [ 'uft', 'qnxs', '' ],
+	       6, -2,
+	       [ 'znp', 'mhnkh', 'bn' ],
+	       'void' ],
+	    );
+
+my $testnum = 171;
+my $failed = 0;
+require POSIX; my $tmp = POSIX::tmpnam();
+foreach my $test (@tests) {
+    my $err = test_splice(@$test);
+    if (defined $err) {
+	print STDERR "# failed: ", Dumper($test);
+	print STDERR "# error: $err\n";
+	$failed = 1;
+	ok($testnum++, 0);
+    }
+    else { ok($testnum++, 1) }
+}
+
+if ($failed) {
+    # Not worth running the random ones
+    print STDERR '# skipping ', $testnum++, "\n";
+}
+else {
+    # A thousand randomly-generated tests
+    $failed = 0;
+    srand(0);
+    foreach (0 .. 1000 - 1) {
+	my $test = rand_test();
+	my $err = test_splice(@$test);
+	if (defined $err) {
+	    print STDERR "# failed: ", Dumper($test);
+	    print STDERR "# error: $err\n";
+	    $failed = 1;
+	    print STDERR "# skipping any remaining random tests\n";
+	    last;
+	}
+    }
+
+    ok($testnum++, not $failed);
+}
+
+die "testnum ($testnum) != total_tests ($total_tests) + 1" 
+    if $testnum != $total_tests + 1;
+
 exit ;
+
+# Subroutines for SPLICE testing
+
+# test_splice()
+# 
+# Test the new splice() against Perl's built-in one.  The first four
+# parameters are those passed to splice(), except that the lists must
+# be (explicitly) passed by reference, and are not actually modified.
+# (It's just a test!)  The last argument specifies the context in
+# which to call the functions: 'list', 'scalar', or 'void'.
+# 
+# Returns:
+#   undef, if the two splices give the same results for the given
+#     arguments and context;
+# 
+#   an error message showing the difference, otherwise.
+# 
+# Reads global variable $tmp.
+# 
+sub test_splice {
+    die 'usage: test_splice(array, offset, length, list, context)' if @_ != 5;
+    my ($array, $offset, $length, $list, $context) = @_;
+    my @array = @$array;
+    my @list = @$list;
+
+    unlink $tmp;
+    
+    my @h;
+    my $H = tie @h, 'DB_File', $tmp, O_CREAT|O_RDWR, 0644, $DB_RECNO
+      or die "cannot open $tmp: $!";
+
+    my $i = 0;
+    foreach ( @array ) { $h[$i++] = $_ }
+    
+    return "basic DB_File sanity check failed"
+      if list_diff(\@array, \@h);
+
+    # Output from splice():
+    # Returned value (munged a bit), error msg, warnings
+    # 
+    my ($s_r, $s_error, @s_warnings);
+
+    my $gather_warning = sub { push @s_warnings, $_[0] };
+    if ($context eq 'list') {
+	my @r;
+	eval {
+	    local $SIG{__WARN__} = $gather_warning;
+	    @r = splice @array, $offset, $length, @list;
+	};
+	$s_error = $@;
+	$s_r = \@r;
+    }
+    elsif ($context eq 'scalar') {
+	my $r;
+	eval {
+	    local $SIG{__WARN__} = $gather_warning;
+	    $r = splice @array, $offset, $length, @list;
+	};
+	$s_error = $@;
+	$s_r = [ $r ];
+    }
+    elsif ($context eq 'void') {
+	eval {
+	    local $SIG{__WARN__} = $gather_warning;
+	    splice @array, $offset, $length, @list;
+	};
+	$s_error = $@;
+	$s_r = [];
+    }
+    else {
+	die "bad context $context";
+    }
+
+    foreach ($s_error, @s_warnings) {
+	chomp;
+	s/ at \S+ line \d+\.$//;
+    }
+
+    # Now do the same for DB_File's version of splice
+    my ($ms_r, $ms_error, @ms_warnings);
+    $gather_warning = sub { push @ms_warnings, $_[0] };
+    if ($context eq 'list') {
+	my @r;
+	eval {
+	    local $SIG{__WARN__} = $gather_warning;
+	    @r = splice @h, $offset, $length, @list;
+	};
+	$ms_error = $@;
+	$ms_r = \@r;
+    }
+    elsif ($context eq 'scalar') {
+	my $r;
+	eval {
+	    local $SIG{__WARN__} = $gather_warning;
+	    $r = splice @h, $offset, $length, @list;
+	};
+	$ms_error = $@;
+	$ms_r = [ $r ];
+    }
+    elsif ($context eq 'void') {
+	eval {
+	    local $SIG{__WARN__} = $gather_warning;
+	    splice @h, $offset, $length, @list;
+	};
+	$ms_error = $@;
+	$ms_r = [];
+    }
+    else {
+	die "bad context $context";
+    }
+
+    foreach ($ms_error, @ms_warnings) {
+	chomp;
+	s/ at \S+ line \d+\.?.*//s;
+    }
+
+    return "different errors: '$s_error' vs '$ms_error'"
+      if $s_error ne $ms_error;
+    return('different return values: ' . Dumper($s_r) . ' vs ' . Dumper($ms_r))
+      if list_diff($s_r, $ms_r);
+    return('different changed list: ' . Dumper(\@array) . ' vs ' . Dumper(\@h))
+      if list_diff(\@array, \@h);
+
+    if ((scalar @s_warnings) != (scalar @ms_warnings)) {
+	return 'different number of warnings';
+    }
+
+    while (@s_warnings) {
+	my $sw  = shift @s_warnings;
+	my $msw = shift @ms_warnings;
+	
+	if (defined $sw and defined $msw) {
+	    $msw =~ s/ \(.+\)$//;
+	    $msw =~ s/ in splice$// if $] < 5.006;
+	    if ($sw ne $msw) {
+		return "different warning: '$sw' vs '$msw'";
+	    }
+	}
+	elsif (not defined $sw and not defined $msw) {
+	    # Okay.
+	}
+	else {
+	    return "one warning defined, another undef";
+	}
+    }
+    
+    undef $H;
+    untie @h;
+    
+    open(TEXT, $tmp) or die "cannot open $tmp: $!";
+    @h = <TEXT>; normalise @h; chomp @h;
+    close TEXT or die "cannot close $tmp: $!";
+    return('list is different when re-read from disk: '
+	   . Dumper(\@array) . ' vs ' . Dumper(\@h))
+      if list_diff(\@array, \@h);
+
+    unlink $tmp;
+
+    return undef; # success
+}
+
+
+# list_diff()
+#
+# Do two lists differ?
+#
+# Parameters:
+#   reference to first list
+#   reference to second list
+#
+# Returns true iff they differ.  Only works for lists of (string or
+# undef). 
+# 
+# Surely there is a better way to do this?
+# 
+sub list_diff {
+    die 'usage: list_diff(ref to first list, ref to second list)'
+      if @_ != 2;
+    my ($a, $b) = @_;
+    my @a = @$a; my @b = @$b;
+    return 1 if (scalar @a) != (scalar @b);
+    for (my $i = 0; $i < @a; $i++) {
+	my ($ae, $be) = ($a[$i], $b[$i]);
+	if (defined $ae and defined $be) {
+	    return 1 if $ae ne $be;
+	}
+	elsif (not defined $ae and not defined $be) {
+	    # Two undefined values are 'equal'
+	}
+	else {
+	    return 1;
+	}
+    }
+    return 0;
+} 
+
+
+# rand_test()
+# 
+# Think up a random ARRAY, OFFSET, LENGTH, LIST, and context.
+# ARRAY or LIST might be empty, and OFFSET or LENGTH might be
+# undefined.  Return a 'test' - a listref of these five things.
+# 
+sub rand_test {
+    die 'usage: rand_test()' if @_;
+    my @contexts = qw<list scalar void>;
+    my $context = $contexts[int(rand @contexts)];
+    return [ rand_list(),
+	     (rand() < 0.5) ? (int(rand(20)) - 10) : undef,
+	     (rand() < 0.5) ? (int(rand(20)) - 10) : undef,
+	     rand_list(),
+	     $context ];
+}
+
+
+sub rand_list {
+    die 'usage: rand_list()' if @_;
+    my @r;
+
+    while (rand() > 0.1 * (scalar @r + 1)) {
+	push @r, rand_word();
+    }
+    return \@r;
+}
+
+
+sub rand_word {
+    die 'usage: rand_word()' if @_;
+    my $r = '';
+    my @chars = qw<a b c d e f g h i j k l m n o p q r s t u v w x y z>;
+    while (rand() > 0.1 * (length($r) + 1)) {
+	$r .= $chars[int(rand(scalar @chars))];
+    }
+    return $r;
+}
+
+
